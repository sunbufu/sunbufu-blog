<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Collection(容器) | Sunbufu's blog</title><meta name=keywords content="java,,collection"><meta name=description content="collection"><meta name=author content="sunbufu"><link rel=canonical href=https://sunbufu.vercel.app/posts/2018-and-before/2018-06-01-collection/><link crossorigin=anonymous href=/assets/css/stylesheet.min.b50dea21cb69b925c783abc4870e38fef3e55317f404eef2740034ed7a1c0ac5.css integrity="sha256-tQ3qIctpuSXHg6vEhw44/vPlUxf0BO7ydAA07XocCsU=" rel="preload stylesheet" as=style><link rel=preload href=/icon/favicon-152x152.png as=image><link rel=icon href=https://sunbufu.vercel.app/icon/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://sunbufu.vercel.app/icon/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://sunbufu.vercel.app/icon/favicon-32x32.png><link rel=apple-touch-icon href=https://sunbufu.vercel.app/icon/apple-touch-icon.png><link rel=mask-icon href=https://sunbufu.vercel.app/icon/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.83.1"><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(a,e,f,g,b,c,d){a.GoogleAnalyticsObject=b,a[b]=a[b]||function(){(a[b].q=a[b].q||[]).push(arguments)},a[b].l=1*new Date,c=e.createElement(f),d=e.getElementsByTagName(f)[0],c.async=1,c.src=g,d.parentNode.insertBefore(c,d)}(window,document,'script','https://www.google-analytics.com/analytics.js','ga'),ga('create','UA-123-45','auto'),ga('send','pageview'))</script><meta property="og:title" content="Collection(容器)"><meta property="og:description" content="collection"><meta property="og:type" content="article"><meta property="og:url" content="https://sunbufu.vercel.app/posts/2018-and-before/2018-06-01-collection/"><meta property="og:image" content="https://sunbufu.vercel.app/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2018-06-01T00:00:00+00:00"><meta property="article:modified_time" content="2018-06-01T00:00:00+00:00"><meta property="og:site_name" content="ExampleSite"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://sunbufu.vercel.app/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Collection(容器)"><meta name=twitter:description content="collection"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://sunbufu.vercel.app/posts/"},{"@type":"ListItem","position":2,"name":"Collection(容器)","item":"https://sunbufu.vercel.app/posts/2018-and-before/2018-06-01-collection/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Collection(容器)","name":"Collection(容器)","description":"collection","keywords":["java,","collection"],"articleBody":"0、容器 特点：  存储各种各样的数据，以对象为单位； 大小容量没有限制； 存储元素最后变成object类型（统称为object类型）。  1、容器接口  Collection ：集合 Set ：元素无序不重复。 SortedSet ：有序set，可按大小自动排序，但仍然不重复。 List ：元素有序可重复。 Map ：(key-value)键值对，统称为元素。key是唯一的，值可以重复。且所有元素是无序的。 SortedMap ：有序Map，所有元素按照key的大小排序，元素不重复。  2、常用实现类 数据结构 ：逻辑关系，物理关系\n3、接口及其实现类特点 1）Set接口 1、Set接口的特性与其实现类是什么？  元素无序； 元素不重复；当添加重复的元素时，它会采用屏蔽技术屏蔽掉。 它的常用实现类: HashSet.  2、HashSet实现类的特性？  元素无序； 元素不重复；当添加重复的元素时，它会采用屏蔽技术屏蔽掉。 个性: 判断元素相等依赖 equals()方法， 但，同时，它还依赖 hashCode()方法。\n注意:   在Java语言中，规定 任何一个对象均有一个哈希编码，该编码是一个int型的整数，由系统自动生成。规则 相等的对象拥有相同的哈希编码值。 自定义类如果使用HashSet必须重写equals（）和HashCode（）方法。  2）SortedSet 接口 1、SortedSet接口的特性及其实现类:  元素自动排序（按大小）; 元素不重复; 当添加重复的元素时会采用屏蔽技术屏蔽掉。 它的常用实现类: TreeSet .  2、TreeSet实现类的特性:  元素自动排序（按大小）; 元素不重复; 当添加重复的元素时会采用屏蔽技术屏蔽掉。 个性: 判断元素相等依赖equals()，但它实质上依赖 compareTo()方法。\n注意：自定义类如果使用TreeSet必须实现comparable接口的compareTo()方法。  3）List接口 1、List接口的特性和常用实现类  元素在位置上是有序。即: 每个元素拥有一个位置编号，它从0开始到 size()-1； 元素可以重复。因为，重复的元素可以在不同的位置上。 个性: 它比较父接口 Collection多了一些与位置相关的操作方法。   如: 获取某个位置上的元素，删除某个位置上的元素，修改某个位置上的元素等。\n 它的常用实现类: LinkedList 和 ArrayList 。  List的实现类 1、LinkedList实现类 和 ArrayList实现类的特性 a) 元素在位置上是有序;\nb) 元素可以重复;\n LinkedList实现类采用链表的原理来管理所有元素。 ArrayList实现类采用队列的原来来管理所有元素。 LinkedList特点: 在插入和删除元素时效率较高，而查询元素时效率较低 。 ArrayList特点: 在插入和删除元素时效率较低，而查询元素时效率较高 。  2、在Java中，专门为List接口提供一个迭代器，实现正向遍历和逆向遍历。 Iterator 迭代器接口\nListIterator 迭代器接口 (注意: 这是List接口独有的)。\n3、在Java中，专门为List接口提供了一个工具类 java.util.Collections，用来实现List接口相关的容器进行排序等操作。 4）Map接口 1、Map接口的特性及其常用实现类:  元素由键和值组成，其中键是唯一，而值可以重复。键对应着值。 元素无序。即: 元素没有按键排序。 元素不重复。当添加重复的元素时采用覆盖技术，用新元素的值去覆盖旧元素的值。 它的常用实现类为: HashMap 它有一个子接口: SortedMap。 Map接口提供的抽象方法：   put(key, value); //添加元素\n 2、通过keySet()来实现 Map相关的容器进行遍历。 Set keys = m1.keySet(); //1 获取所有元素的键，并构建一个集合。 Iterator it = keys.iterator(); //2 获取一个迭代器 while( it.hasNext() ){ //3 判断  Object key = it.next(); //4 访问  Object value = m1.get( key ); //5 通过容器本身的方法来获取键对应的值。  System.out.println( key + \"  \" + value ); } Map接口的实现类 1、HashMap实现类的特性:  元素由键(Key)和值(Value)组成，键对应着值； 其中键是唯一的，值可重复。 元素无序。 元素不重复。添加重复元素时采用覆盖技术。 个性: 判断元素相等(实质是判断元素的键是否相等)依赖 equals()方法，同时，它还依赖 hashCode()方法。\n结论:\n当容器由 HashMap 实现类所构建，且元素的键为自定义类型时，则该键对应的类必须重写 equals()和hashCode()两个方法。  2、TreeMap接口 1、SortedMap 接口的特性及其实现类:  元素按键的大小自动排序。 元素不重复。当添加重复的元素时采用覆盖技术。 它常用实现类 TreeMap .  2、TreeMap实现类的特性:  元素按键的大小自动排序。 元素不重复。当添加重复的元素时采用覆盖技术。 个性: 判断元素相等( 实质上是判断元素的键是否相等 )依赖 compareTo()方法。  结论: 1)当 容器由 TreeMap 实现类所构建，且元素的键是自定义类的对象时，则该类必须实现 Comparable接口，重写 compareTo()方法。\n2)同时，注意: 在重写compareTo()方法时，要对对象的所有属性一一比较大小。\n实现类的特点\nHashSet ：\n如果容器内已经存在（通过equals（）和HashCode（）方法判断相等），则屏蔽。 注意：自定义方法如果使用HashSet必须重写equals（）和HashCode（）方法。\nTreeSet ：\n判断元素相等依赖于equals（），但实质上依赖于compareTo（）方法。\n常用方法 //collection常用方法 boolean add(Object element);// 添加元素 boolean remove(Object element);// 移除元素 boolean contains(Object element);// 是否包含元素 int size();// 容器大小 boolean isEmpty();// 是否为空 void clear();// 清空容器 iterator iterator();// 遍历容器 boolean containsAll(Collection c);// 是否包含某容器 boolean addAll(Collection c);// 添加容器内的元素 boolean removeAll(Collection c);// 移除参数容器内的元素 boolean retainAll(Collection c);// 取两容器交集 Object[] toArray();// 将容器转换为数组 //List常用方法： // 和Collection相比，多了添加了一些和顺序有关的方法 void add(int index, Object element);// 添加元素到指定位置 Object get(int index);// 获取指定位置的元素 Object set(int index, Object element);// 更改指定位置的元素 Object remove(int index);// 移除指定位置的元素 int indexOf(Object element);// 返回某个元素的索引。如果没有该元素，返回-1 //Map常用方法： Object put(Object key, Object value);// 添加元素 Object get(Object key);// 获取指定key的元素的value Object remove(Object key);// 移除指定key的元素 boolean containsKey(Object key);// 是否包含指定key的元素 boolean containsValue(Object value);// 是否包含指定value的元素 int size();// 获取map的大小 boolean isEmpty();// map是否为空 void putAll(Map map);// 将map放入map中 void clear();// 移除map中所有元素 java.util.Collections 工具类方法：\n","wordCount":"314","inLanguage":"en","datePublished":"2018-06-01T00:00:00Z","dateModified":"2018-06-01T00:00:00Z","author":{"@type":"Person","name":"sunbufu"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://sunbufu.vercel.app/posts/2018-and-before/2018-06-01-collection/"},"publisher":{"@type":"Organization","name":"Sunbufu's blog","logo":{"@type":"ImageObject","url":"https://sunbufu.vercel.app/icon/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script><noscript><style type=text/css>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:#1d1e20;--entry:#2e2e33;--primary:rgba(255, 255, 255, 0.84);--secondary:rgba(255, 255, 255, 0.56);--tertiary:rgba(255, 255, 255, 0.16);--content:rgba(255, 255, 255, 0.74);--hljs-bg:#2e2e33;--code-bg:#37383e;--border:#333}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://sunbufu.vercel.app/ accesskey=h title="Sunbufu's blog (Alt + H)">Sunbufu's blog</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://sunbufu.vercel.app/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://sunbufu.vercel.app/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://sunbufu.vercel.app/about/ title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://sunbufu.vercel.app/>Home</a>&nbsp;»&nbsp;<a href=https://sunbufu.vercel.app/posts/>Posts</a></div><h1 class=post-title>Collection(容器)</h1><div class=post-description>collection</div><div class=post-meta>June 1, 2018&nbsp;·&nbsp;2 min&nbsp;·&nbsp;sunbufu</div></header><div class=post-content><h1 id=0容器-特点>0、容器 特点：<a hidden class=anchor aria-hidden=true href=#0容器-特点>#</a></h1><ul><li>存储各种各样的数据，以对象为单位；</li><li>大小容量没有限制；</li><li>存储元素最后变成object类型（统称为object类型）。</li></ul><h1 id=1容器接口>1、容器接口<a hidden class=anchor aria-hidden=true href=#1容器接口>#</a></h1><p><img loading=lazy src=/posts/2018-and-before/20151026090908536.jpg alt=容器接口></p><ul><li>Collection ：集合</li><li>Set ：元素无序不重复。</li><li>SortedSet ：有序set，可按大小自动排序，但仍然不重复。</li><li>List ：元素有序可重复。</li><li>Map ：(key-value)键值对，统称为元素。key是唯一的，值可以重复。且所有元素是无序的。</li><li>SortedMap ：有序Map，所有元素按照key的大小排序，元素不重复。</li></ul><h1 id=2常用实现类>2、常用实现类<a hidden class=anchor aria-hidden=true href=#2常用实现类>#</a></h1><p><img loading=lazy src=/posts/2018-and-before/20151026090940288.jpg alt=容器实现类>
数据结构 ：逻辑关系，物理关系</p><h1 id=3接口及其实现类特点>3、接口及其实现类特点<a hidden class=anchor aria-hidden=true href=#3接口及其实现类特点>#</a></h1><h2 id=1set接口>1）Set接口<a hidden class=anchor aria-hidden=true href=#1set接口>#</a></h2><h3 id=1set接口的特性与其实现类是什么>1、Set接口的特性与其实现类是什么？<a hidden class=anchor aria-hidden=true href=#1set接口的特性与其实现类是什么>#</a></h3><ol><li>元素无序；</li><li>元素不重复；当添加重复的元素时，它会采用屏蔽技术屏蔽掉。</li><li>它的常用实现类: <code>HashSet</code>.</li></ol><h3 id=2hashset实现类的特性>2、HashSet实现类的特性？<a hidden class=anchor aria-hidden=true href=#2hashset实现类的特性>#</a></h3><ol><li>元素无序；</li><li>元素不重复；当添加重复的元素时，它会采用屏蔽技术屏蔽掉。</li><li>个性: 判断元素相等依赖 equals()方法， 但，同时，它还依赖 hashCode()方法。<br><strong>注意</strong>:</li></ol><ol><li>在Java语言中，规定 任何一个对象均有一个哈希编码，该编码是一个int型的整数，由系统自动生成。规则 相等的对象拥有相同的哈希编码值。</li><li>自定义类如果使用HashSet必须重写equals（）和HashCode（）方法。</li></ol><h2 id=2sortedset-接口>2）SortedSet 接口<a hidden class=anchor aria-hidden=true href=#2sortedset-接口>#</a></h2><h3 id=1sortedset接口的特性及其实现类>1、SortedSet接口的特性及其实现类:<a hidden class=anchor aria-hidden=true href=#1sortedset接口的特性及其实现类>#</a></h3><ol><li>元素自动排序（按大小）;</li><li>元素不重复; 当添加重复的元素时会采用屏蔽技术屏蔽掉。</li><li>它的常用实现类: TreeSet .</li></ol><h3 id=2treeset实现类的特性>2、TreeSet实现类的特性:<a hidden class=anchor aria-hidden=true href=#2treeset实现类的特性>#</a></h3><ol><li>元素自动排序（按大小）;</li><li>元素不重复; 当添加重复的元素时会采用屏蔽技术屏蔽掉。</li><li><strong>个性</strong>: 判断元素相等依赖<code>equals()</code>，但它实质上依赖 <code>compareTo()</code>方法。<br><strong>注意：自定义类如果使用TreeSet必须实现<code>comparable</code>接口的<code>compareTo()</code>方法。</strong></li></ol><h2 id=3list接口>3）List接口<a hidden class=anchor aria-hidden=true href=#3list接口>#</a></h2><h3 id=1list接口的特性和常用实现类>1、List接口的特性和常用实现类<a hidden class=anchor aria-hidden=true href=#1list接口的特性和常用实现类>#</a></h3><ol><li>元素在位置上是有序。即: 每个元素拥有一个位置编号，它从0开始到 <code>size()-1</code>；</li><li>元素可以重复。因为，重复的元素可以在不同的位置上。</li><li>个性: 它比较父接口 Collection多了一些与位置相关的操作方法。</li></ol><blockquote><p>如: 获取某个位置上的元素，删除某个位置上的元素，修改某个位置上的元素等。</p></blockquote><ol start=4><li>它的常用实现类: <code>LinkedList</code> 和 <code>ArrayList</code> 。</li></ol><h3 id=list的实现类>List的实现类<a hidden class=anchor aria-hidden=true href=#list的实现类>#</a></h3><h4 id=1linkedlist实现类-和-arraylist实现类的特性>1、LinkedList实现类 和 ArrayList实现类的特性<a hidden class=anchor aria-hidden=true href=#1linkedlist实现类-和-arraylist实现类的特性>#</a></h4><p>a) 元素在位置上是有序;<br>b) 元素可以重复;</p><ol><li>LinkedList实现类采用链表的原理来管理所有元素。</li><li>ArrayList实现类采用队列的原来来管理所有元素。</li><li><strong>LinkedList</strong>特点: 在<strong>插入和删除元素时效率较高</strong>，而查询元素时效率较低 。</li><li><strong>ArrayList</strong>特点: 在插入和删除元素时效率较低，而<strong>查询元素时效率较高</strong> 。</li></ol><h4 id=2在java中专门为list接口提供一个迭代器实现正向遍历和逆向遍历>2、在Java中，专门为List接口提供一个迭代器，实现正向遍历和逆向遍历。<a hidden class=anchor aria-hidden=true href=#2在java中专门为list接口提供一个迭代器实现正向遍历和逆向遍历>#</a></h4><p><code>Iterator</code> 迭代器接口<br><code>ListIterator</code> 迭代器接口 (<strong>注意: 这是List接口独有的</strong>)。</p><h4 id=3在java中专门为list接口提供了一个工具类-javautilcollections用来实现list接口相关的容器进行排序等操作>3、在Java中，专门为List接口提供了一个工具类 <code>java.util.Collections</code>，用来实现List接口相关的容器进行排序等操作。<a hidden class=anchor aria-hidden=true href=#3在java中专门为list接口提供了一个工具类-javautilcollections用来实现list接口相关的容器进行排序等操作>#</a></h4><h2 id=4map接口>4）Map接口<a hidden class=anchor aria-hidden=true href=#4map接口>#</a></h2><h3 id=1map接口的特性及其常用实现类>1、Map接口的特性及其常用实现类:<a hidden class=anchor aria-hidden=true href=#1map接口的特性及其常用实现类>#</a></h3><ol><li>元素由键和值组成，其中键是唯一，而值可以重复。键对应着值。</li><li>元素无序。即: 元素没有按键排序。</li><li>元素不重复。当添加重复的元素时采用覆盖技术，用新元素的值去覆盖旧元素的值。</li><li>它的常用实现类为: <code>HashMap</code></li><li>它有一个子接口: <code>SortedMap</code>。</li><li>Map接口提供的抽象方法：</li></ol><blockquote><p><code>put(key, value);</code> //添加元素</p></blockquote><h3 id=2通过keyset来实现-map相关的容器进行遍历>2、通过<code>keySet()</code>来实现 <code>Map</code>相关的容器进行遍历。<a hidden class=anchor aria-hidden=true href=#2通过keyset来实现-map相关的容器进行遍历>#</a></h3><div class=highlight><pre style=color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java>Set keys <span style=color:#5bc4bf>=</span> m1<span style=color:#5bc4bf>.</span><span style=color:#06b6ef>keySet</span><span style=color:#5bc4bf>();</span> <span style=color:#776e71>//1 获取所有元素的键，并构建一个集合。
</span><span style=color:#776e71></span>Iterator it <span style=color:#5bc4bf>=</span> keys<span style=color:#5bc4bf>.</span><span style=color:#06b6ef>iterator</span><span style=color:#5bc4bf>();</span> <span style=color:#776e71>//2 获取一个迭代器
</span><span style=color:#776e71></span><span style=color:#815ba4>while</span><span style=color:#5bc4bf>(</span> it<span style=color:#5bc4bf>.</span><span style=color:#06b6ef>hasNext</span><span style=color:#5bc4bf>()</span> <span style=color:#5bc4bf>){</span> <span style=color:#776e71>//3 判断
</span><span style=color:#776e71></span>    Object key <span style=color:#5bc4bf>=</span> it<span style=color:#5bc4bf>.</span><span style=color:#06b6ef>next</span><span style=color:#5bc4bf>();</span> <span style=color:#776e71>//4 访问
</span><span style=color:#776e71></span>    Object value <span style=color:#5bc4bf>=</span> m1<span style=color:#5bc4bf>.</span><span style=color:#06b6ef>get</span><span style=color:#5bc4bf>(</span> key <span style=color:#5bc4bf>);</span> <span style=color:#776e71>//5 通过容器本身的方法来获取键对应的值。
</span><span style=color:#776e71></span>    System<span style=color:#5bc4bf>.</span><span style=color:#06b6ef>out</span><span style=color:#5bc4bf>.</span><span style=color:#06b6ef>println</span><span style=color:#5bc4bf>(</span> key <span style=color:#5bc4bf>+</span> <span style=color:#48b685>&#34; &lt;&lt;&lt;===&gt;&gt;&gt; &#34;</span> <span style=color:#5bc4bf>+</span> value <span style=color:#5bc4bf>);</span>
<span style=color:#5bc4bf>}</span>
</code></pre></div><h3 id=map接口的实现类>Map接口的实现类<a hidden class=anchor aria-hidden=true href=#map接口的实现类>#</a></h3><h4 id=1hashmap实现类的特性>1、<code>HashMap</code>实现类的特性:<a hidden class=anchor aria-hidden=true href=#1hashmap实现类的特性>#</a></h4><ol><li>元素由键(Key)和值(Value)组成，键对应着值； 其中键是唯一的，值可重复。</li><li>元素无序。</li><li>元素不重复。添加重复元素时采用覆盖技术。</li><li>个性: 判断元素相等(实质是判断元素的键是否相等)依赖 <code>equals()</code>方法，同时，它还依赖 <code>hashCode()</code>方法。<br><strong>结论:</strong><br>当容器由 <code>HashMap</code> 实现类所构建，且元素的键为自定义类型时，则该键对应的类必须重写 <code>equals()</code>和<code>hashCode()</code>两个方法。</li></ol><h2 id=2treemap接口>2、TreeMap接口<a hidden class=anchor aria-hidden=true href=#2treemap接口>#</a></h2><h3 id=1sortedmap-接口的特性及其实现类>1、SortedMap 接口的特性及其实现类:<a hidden class=anchor aria-hidden=true href=#1sortedmap-接口的特性及其实现类>#</a></h3><ol><li>元素按键的大小自动排序。</li><li>元素不重复。当添加重复的元素时采用覆盖技术。</li><li>它常用实现类 TreeMap .</li></ol><h3 id=2treemap实现类的特性>2、TreeMap实现类的特性:<a hidden class=anchor aria-hidden=true href=#2treemap实现类的特性>#</a></h3><ol><li>元素按键的大小自动排序。</li><li>元素不重复。当添加重复的元素时采用覆盖技术。</li><li>个性: 判断元素相等( 实质上是判断元素的键是否相等 )依赖 compareTo()方法。</li></ol><h3 id=结论>结论:<a hidden class=anchor aria-hidden=true href=#结论>#</a></h3><p>1)当 容器由 TreeMap 实现类所构建，且元素的键是自定义类的对象时，则该类必须实现 Comparable接口，重写 compareTo()方法。<br>2)同时，注意: 在重写compareTo()方法时，要对对象的所有属性一一比较大小。<br>实现类的<strong>特点</strong><br>HashSet ：<br>如果容器内已经存在（通过equals（）和HashCode（）方法判断相等），则屏蔽。 注意：自定义方法如果使用HashSet必须重写equals（）和HashCode（）方法。<br>TreeSet ：<br>判断元素相等依赖于equals（），但实质上依赖于compareTo（）方法。</p><h1 id=常用方法>常用方法<a hidden class=anchor aria-hidden=true href=#常用方法>#</a></h1><div class=highlight><pre style=color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#776e71>//collection常用方法
</span><span style=color:#776e71></span><span style=color:#fec418>boolean</span> <span style=color:#06b6ef>add</span><span style=color:#5bc4bf>(</span>Object element<span style=color:#5bc4bf>);</span><span style=color:#776e71>// 添加元素
</span><span style=color:#776e71></span><span style=color:#fec418>boolean</span> <span style=color:#06b6ef>remove</span><span style=color:#5bc4bf>(</span>Object element<span style=color:#5bc4bf>);</span><span style=color:#776e71>// 移除元素
</span><span style=color:#776e71></span><span style=color:#fec418>boolean</span> <span style=color:#06b6ef>contains</span><span style=color:#5bc4bf>(</span>Object element<span style=color:#5bc4bf>);</span><span style=color:#776e71>// 是否包含元素
</span><span style=color:#776e71></span><span style=color:#fec418>int</span> <span style=color:#06b6ef>size</span><span style=color:#5bc4bf>();</span><span style=color:#776e71>// 容器大小
</span><span style=color:#776e71></span><span style=color:#fec418>boolean</span> <span style=color:#06b6ef>isEmpty</span><span style=color:#5bc4bf>();</span><span style=color:#776e71>// 是否为空
</span><span style=color:#776e71></span><span style=color:#fec418>void</span> <span style=color:#06b6ef>clear</span><span style=color:#5bc4bf>();</span><span style=color:#776e71>// 清空容器
</span><span style=color:#776e71></span>iterator <span style=color:#06b6ef>iterator</span><span style=color:#5bc4bf>();</span><span style=color:#776e71>// 遍历容器
</span><span style=color:#776e71></span><span style=color:#fec418>boolean</span> <span style=color:#06b6ef>containsAll</span><span style=color:#5bc4bf>(</span>Collection c<span style=color:#5bc4bf>);</span><span style=color:#776e71>// 是否包含某容器
</span><span style=color:#776e71></span><span style=color:#fec418>boolean</span> <span style=color:#06b6ef>addAll</span><span style=color:#5bc4bf>(</span>Collection c<span style=color:#5bc4bf>);</span><span style=color:#776e71>// 添加容器内的元素
</span><span style=color:#776e71></span><span style=color:#fec418>boolean</span> <span style=color:#06b6ef>removeAll</span><span style=color:#5bc4bf>(</span>Collection c<span style=color:#5bc4bf>);</span><span style=color:#776e71>// 移除参数容器内的元素
</span><span style=color:#776e71></span><span style=color:#fec418>boolean</span> <span style=color:#06b6ef>retainAll</span><span style=color:#5bc4bf>(</span>Collection c<span style=color:#5bc4bf>);</span><span style=color:#776e71>// 取两容器交集
</span><span style=color:#776e71></span>Object<span style=color:#5bc4bf>[]</span> <span style=color:#06b6ef>toArray</span><span style=color:#5bc4bf>();</span><span style=color:#776e71>// 将容器转换为数组
</span><span style=color:#776e71>//List常用方法：
</span><span style=color:#776e71>// 和Collection相比，多了添加了一些和顺序有关的方法
</span><span style=color:#776e71></span><span style=color:#fec418>void</span> <span style=color:#06b6ef>add</span><span style=color:#5bc4bf>(</span><span style=color:#fec418>int</span> index<span style=color:#5bc4bf>,</span> Object element<span style=color:#5bc4bf>);</span><span style=color:#776e71>// 添加元素到指定位置
</span><span style=color:#776e71></span>Object <span style=color:#06b6ef>get</span><span style=color:#5bc4bf>(</span><span style=color:#fec418>int</span> index<span style=color:#5bc4bf>);</span><span style=color:#776e71>// 获取指定位置的元素
</span><span style=color:#776e71></span>Object <span style=color:#06b6ef>set</span><span style=color:#5bc4bf>(</span><span style=color:#fec418>int</span> index<span style=color:#5bc4bf>,</span> Object element<span style=color:#5bc4bf>);</span><span style=color:#776e71>// 更改指定位置的元素
</span><span style=color:#776e71></span>Object <span style=color:#06b6ef>remove</span><span style=color:#5bc4bf>(</span><span style=color:#fec418>int</span> index<span style=color:#5bc4bf>);</span><span style=color:#776e71>// 移除指定位置的元素
</span><span style=color:#776e71></span><span style=color:#fec418>int</span> <span style=color:#06b6ef>indexOf</span><span style=color:#5bc4bf>(</span>Object element<span style=color:#5bc4bf>);</span><span style=color:#776e71>// 返回某个元素的索引。如果没有该元素，返回-1
</span><span style=color:#776e71>//Map常用方法：
</span><span style=color:#776e71></span>Object <span style=color:#06b6ef>put</span><span style=color:#5bc4bf>(</span>Object key<span style=color:#5bc4bf>,</span> Object value<span style=color:#5bc4bf>);</span><span style=color:#776e71>// 添加元素
</span><span style=color:#776e71></span>Object <span style=color:#06b6ef>get</span><span style=color:#5bc4bf>(</span>Object key<span style=color:#5bc4bf>);</span><span style=color:#776e71>// 获取指定key的元素的value
</span><span style=color:#776e71></span>Object <span style=color:#06b6ef>remove</span><span style=color:#5bc4bf>(</span>Object key<span style=color:#5bc4bf>);</span><span style=color:#776e71>// 移除指定key的元素
</span><span style=color:#776e71></span><span style=color:#fec418>boolean</span> <span style=color:#06b6ef>containsKey</span><span style=color:#5bc4bf>(</span>Object key<span style=color:#5bc4bf>);</span><span style=color:#776e71>// 是否包含指定key的元素
</span><span style=color:#776e71></span><span style=color:#fec418>boolean</span> <span style=color:#06b6ef>containsValue</span><span style=color:#5bc4bf>(</span>Object value<span style=color:#5bc4bf>);</span><span style=color:#776e71>// 是否包含指定value的元素
</span><span style=color:#776e71></span><span style=color:#fec418>int</span> <span style=color:#06b6ef>size</span><span style=color:#5bc4bf>();</span><span style=color:#776e71>// 获取map的大小
</span><span style=color:#776e71></span><span style=color:#fec418>boolean</span> <span style=color:#06b6ef>isEmpty</span><span style=color:#5bc4bf>();</span><span style=color:#776e71>// map是否为空
</span><span style=color:#776e71></span><span style=color:#fec418>void</span> <span style=color:#06b6ef>putAll</span><span style=color:#5bc4bf>(</span>Map map<span style=color:#5bc4bf>);</span><span style=color:#776e71>// 将map放入map中
</span><span style=color:#776e71></span><span style=color:#fec418>void</span> <span style=color:#06b6ef>clear</span><span style=color:#5bc4bf>();</span><span style=color:#776e71>// 移除map中所有元素
</span></code></pre></div><p>java.util.Collections 工具类方法：</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://sunbufu.vercel.app/tags/java/>java</a></li></ul><nav class=paginav><a class=prev href=https://sunbufu.vercel.app/posts/2018-and-before/2018-06-02-redirect-forward/><span class=title>« Prev Page</span><br><span>重定向与请求转发</span></a>
<a class=next href=https://sunbufu.vercel.app/posts/2018-and-before/2018-06-01-html/><span class=title>Next Page »</span><br><span>html</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2021 <a href=https://sunbufu.vercel.app/>Sunbufu's blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)"><button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></button></a>
<script>let menu=document.getElementById('menu');menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)},document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script></body></html>