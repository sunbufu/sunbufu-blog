<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>正则表达式 | Sunbufu's blog</title><meta name=keywords content="正则表达式"><meta name=description content="regular expression"><meta name=author content="sunbufu"><link rel=canonical href=https://sunbufu.vercel.app/posts/2018-and-before/2018-06-02-rex/><link crossorigin=anonymous href=/assets/css/stylesheet.min.b50dea21cb69b925c783abc4870e38fef3e55317f404eef2740034ed7a1c0ac5.css integrity="sha256-tQ3qIctpuSXHg6vEhw44/vPlUxf0BO7ydAA07XocCsU=" rel="preload stylesheet" as=style><link rel=preload href=/icon/favicon-152x152.png as=image><link rel=icon href=https://sunbufu.vercel.app/icon/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://sunbufu.vercel.app/icon/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://sunbufu.vercel.app/icon/favicon-32x32.png><link rel=apple-touch-icon href=https://sunbufu.vercel.app/icon/apple-touch-icon.png><link rel=mask-icon href=https://sunbufu.vercel.app/icon/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.83.1"><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(a,e,f,g,b,c,d){a.GoogleAnalyticsObject=b,a[b]=a[b]||function(){(a[b].q=a[b].q||[]).push(arguments)},a[b].l=1*new Date,c=e.createElement(f),d=e.getElementsByTagName(f)[0],c.async=1,c.src=g,d.parentNode.insertBefore(c,d)}(window,document,'script','https://www.google-analytics.com/analytics.js','ga'),ga('create','UA-123-45','auto'),ga('send','pageview'))</script><meta property="og:title" content="正则表达式"><meta property="og:description" content="regular expression"><meta property="og:type" content="article"><meta property="og:url" content="https://sunbufu.vercel.app/posts/2018-and-before/2018-06-02-rex/"><meta property="og:image" content="https://sunbufu.vercel.app/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2018-06-02T00:00:00+00:00"><meta property="article:modified_time" content="2018-06-02T00:00:00+00:00"><meta property="og:site_name" content="ExampleSite"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://sunbufu.vercel.app/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="正则表达式"><meta name=twitter:description content="regular expression"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://sunbufu.vercel.app/posts/"},{"@type":"ListItem","position":2,"name":"正则表达式","item":"https://sunbufu.vercel.app/posts/2018-and-before/2018-06-02-rex/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"正则表达式","name":"正则表达式","description":"regular expression","keywords":["正则表达式"],"articleBody":"引言 正则表达式（regular expression）就是用一个“字符串”来描述一个特征，然后去验证另一个“字符串”是否符合这个特征。比如 表达式“ab+” 描述的特征是“一个 ‘a’ 和 任意个 ‘b’ ”，那么 ‘ab’, ‘abb’, ‘abbbbbbbbbb’ 都符合这个特征。\n正则表达式可以用来：\n 验证字符串是否符合指定特征，比如验证是否是合法的邮件地址。 用来查找字符串，从一个长的文本中查找符合指定特征的字符串，比查找固定字符串更加灵活方便。 用来替换，比普通的替换更强大。  正则表达式学习起来其实是很简单的，不多的几个较为抽象的概念也很容易理解。之所以很多人感觉正则表达式比较复杂，一方面是因为大多数的文档没有做到由浅入深地讲解，概念上没有注意先后顺序，给读者的理解带来困难；另一方面，各种引擎自带的文档一般都要介绍它特有的功能，然而这部分特有的功能并不是我们首先要理解的。\n一、 正则表达式规则 1.1 普通字符 字母、数字、汉字、下划线、以及后边章节中没有特殊定义的标点符号，都是\"普通字符\"。表达式中的普通字符，在匹配一个字符串的时候，匹配与之相同的一个字符。\n1.2 简单的转义字符 一些不便书写的字符，采用在前面加 \"\\\" 的方法。这些字符其实我们都已经熟知了。\n   表达式 可匹配     \\r,\\n 代表回车和换行符   \\t 制表符   \\\\ 代表\\本身    还有其他一些在后边章节中有特殊用处的标点符号，在前面加 \"\\\" 后，就代表该符号本身。比如：^, $ 都有特殊意义，如果要想匹配字符串中 \"^\" 和 \"$\" 字符，则表达式就需要写成 \"\\^\" 和 \"\\$\"。\n   表达式 可匹配     \\^ 匹配^符号本身   \\$ 匹配$符号本身   \\. 匹配小数点.本身    这些转义字符的匹配方法与 “普通字符” 是类似的。也是匹配与之相同的一个字符。\n1.3 能够与 ‘多种字符’ 匹配的表达式 正则表达式中的一些表示方法，可以匹配 ‘多种字符’ 其中的任意一个字符。比如，表达式 \"\\d\" 可以匹配任意一个数字。虽然可以匹配其中任意字符，但是只能是一个，不是多个。这就好比玩扑克牌时候，大小王可以代替任意一张牌，但是只能代替一张牌。\n   表达式 可匹配     \\d 任意一个数字，0~9 中的任意一个   \\w 任意一个字母或数字或下划线，也就是A~Z,a~z,0~9,_ 中任意一个   \\s 包括空格、制表符、换页符等空白字符的其中任意一个   . 小数点可以匹配除了换行符（\\n）以外的任意一个字符    1.4 自定义能够匹配 ‘多种字符’ 的表达式 使用方括号 [ ] 包含一系列字符，能够匹配其中任意一个字符。用 [^ ] 包含一系列字符，则能够匹配其中字符之外的任意一个字符。同样的道理，虽然可以匹配其中任意一个，但是只能是一个，不是多个。\n   表达式 可匹配     [ab5@] 匹配 \"a\" 或 \"b\" 或 \"5\" 或 \"@\"   [^abc] 匹配 \"a\",\"b\",\"c\" 之外的任意一个字符   [f-K] 匹配 \"f\"~\"k\" 之间的任意一个字母   [^A-F0-3] 匹配 \"A\"~\"F\",\"0\"~\"3\" 之外的任意一个字符    1.5 修饰匹配次数的特殊符号 前面章节中讲到的表达式，无论是只能匹配一种字符的表达式，还是可以匹配多种字符其中任意一个的表达式，都只能匹配一次。如果使用表达式再加上修饰匹配次数的特殊符号，那么不用重复书写表达式就可以重复匹配。 使用方法是：“次数修饰\"放在\"被修饰的表达式\"后边。比如：\"[bcd][bcd]\" 可以写成 \"[bcd]{2}\"。\n   表达式 作用     {n} 表达式重复n次   {m,n} 表达式至少重复m次，最多重复n次   {m,} 表达式至少重复m次   ? 匹配表达式0次或者1次，相当于{0,1}   + 表达式至少出现1次，相当于{1,}   * 表达式不出现或出现任意次，相当于{0,}    1.6 其他一些代表抽象意义的特殊符号 一些符号在表达式中代表抽象的特殊意义：\n   表达式 作用     ^ 与字符串开始的地方匹配，不匹配任何字符   $ 与字符串结束的地方匹配，不匹配任何字符   \\b 匹配一个单词边界，也就是单词和空格之间的位置，不匹配任何字符    一些符号可以影响表达式内部的子表达式之间的关系：\n   表达式 作用     | 左右两边表达式之间 “或” 关系，匹配左边或者右边   () (1)在被修饰匹配次数的时候，括号中的表达式可以作为整体被修饰 (2)取匹配结果的时候，括号中的表达式匹配到的内容可以被单独得到    二、正则表达式中的一些高级规则 2.1 匹配次数中的贪婪与非贪婪 在使用修饰匹配次数的特殊符号时，有几种表示方法可以使同一个表达式能够匹配不同的次数，比如：\"{m,n}\", \"{m,}\", \"?\", \"*\", \"+\"，具体匹配的次数随被匹配的字符串而定。这种重复匹配不定次数的表达式在匹配过程中，总是尽可能多的匹配。比如，针对文本 \"dxxxdxxxd\"，举例如下：\n   表达式 匹配结果     (d)(\\w+) \"\\w+\" 将匹配第一个 \"d\" 之后的所有字符 \"xxxdxxxd\"   (d)(\\w+)(d) \"\\w+\" 将匹配第一个 \"d\" 和最后一个 \"d\" 之间的所有字符 \"xxxdxxx\"。虽然 \"\\w+\" 也能够匹配上最后一个 \"d\"，但是为了使整个表达式匹配成功，\"\\w+\" 可以 “让出” 它本来能够匹配的最后一个 \"d\"    由此可见，\"\\w+\" 在匹配的时候，总是尽可能多的匹配符合它规则的字符。虽然第二个举例中，它没有匹配最后一个 \"d\"，但那也是为了让整个表达式能够匹配成功。同理，带 \"*\" 和 \"{m,n}\" 的表达式都是尽可能地多匹配，带 \"?\" 的表达式在可匹配可不匹配的时候，也是尽可能的 “要匹配”。这 种匹配原则就叫作 “贪婪” 模式 。\n非贪婪模式： 在修饰匹配次数的特殊符号后再加上一个 \"?\" 号，则可以使匹配次数不定的表达式尽可能少的匹配，使可匹配可不匹配的表达式，尽可能的 “不匹配”。这种匹配原则叫作 “非贪婪” 模式，也叫作 “勉强” 模式。如果少匹配就会导致整个表达式匹配失败的时候，与贪婪模式类似，非贪婪模式会最小限度的再匹配一些，以使整个表达式匹配成功。举例如下，针对文本 \"dxxxdxxxd\" 举例：\n   表达式 匹配结果     (d)(\\w+?) \"\\w+?\" 将尽可能少的匹配第一个 \"d\" 之后的字符，结果是：\"\\w+?\" 只匹配了一个 \"x\"   (d)(\\w+?)(d) 为了让整个表达式匹配成功，\"\\w+?\" 不得不匹配 \"xxx\" 才可以让后边的 \"d\" 匹配，从而使整个表达式匹配成功。因此，结果是：\"\\w+?\" 匹配 \"xxx\"    2.2 反向引用 \\1,\\2… 表达式在匹配时，表达式引擎会将小括号 \"( )\" 包含的表达式所匹配到的字符串记录下来。在获取匹配结果的时候，小括号包含的表达式所匹配到的字符串可以单独获取。这一点，在前面的举例中，已经多次展示了。在实际应用场合中，当用某种边界来查找，而所要获取的内容又不包含边界时，必须使用小括号来指定所要的范围。比如前面的 \"(.*?)\"。 其实，“小括号包含的表达式所匹配到的字符串” 不仅是在匹配结束后才可以使用，在匹配过程中也可以使用。表达式后边的部分，可以引用前面 “括号内的子匹配已经匹配到的字符串”。引用方法是 \"\\\" 加上一个数字。\"\\1\" 引用第1对括号内匹配到的字符串，\"\\2\" 引用第2对括号内匹配到的字符串……以此类推，如果一对括号内包含另一对括号，则外层的括号先排序号。换句话说，哪一对的左括号 \"(\" 在前，那这一对就先排序号。\n2.3 预搜索，不匹配；反向预搜索，不匹配 前面的章节中，我讲到了几个代表抽象意义的特殊符号：\"^\"，\"$\"，\"\\b\"。它们都有一个共同点，那就是：它们本身不匹配任何字符，只是对 “字符串的两头” 或者 “字符之间的缝隙” 附加了一个条件。理解到这个概念以后，本节将继续介绍另外一种对 “两头” 或者 “缝隙” 附加条件的，更加灵活的表示方法。 正向预搜索：\"(?=xxxxx)\"，\"(?!xxxxx)\" 格式：\"(?=xxxxx)\"，在被匹配的字符串中，它对所处的 “缝隙” 或者 “两头” 附加的条件是：所在缝隙的右侧，必须能够匹配上 xxxxx 这部分的表达式。因为它只是在此作为这个缝隙上附加的条件，所以它并不影响后边的表达式去真正匹配这个缝隙之后的字符。这就类似 \"\\b\"，本身不匹配任何字符。\"\\b\" 只是将所在缝隙之前、之后的字符取来进行了一下判断，不会影响后边的表达式来真正的匹配。 反向预搜索：\"(?，\"(? 这两种格式的概念和正向预搜索是类似的，反向预搜索要求的条件是：所在缝隙的 “左侧”，两种格式分别要求必须能够匹配和必须不能够匹配指定表达式，而不是去判断右侧。与 “正向预搜索” 一样的是：它们都是对所在缝隙的一种附加条件，本身都不匹配任何字符。\n三、其他通用规则 还有一些在各个正则表达式引擎之间比较通用的规则，在前面的讲解过程中没有提到。\n3.1 表达式中，可以使用 “\\xXX” 和 “\\uXXXX” 表示一个字符（“X” 表示一个十六进制数）    形式 字符范围     \\xXX 编号在 0 ~ 255 范围的字符   \\uXXXX 任何字符可以使用 \"\\u\" 再加上其编号的4位十六进制数表示    3.2 在表达式 “\\s”，\"\\d”，\"\\w\"，\"\\b\" 表示特殊意义的同时，对应的大写字母表示相反的意义    表达式 可匹配     \\S 匹配所有非空白字符(\\s可匹配各个空白字符)   \\D 匹配所有的非数字字符   \\W 匹配所有的字母、数字、下划线以外的字符   \\B 匹配非单词边界，即左右两边\\w范围或者左右两边都不是\\w范围时的字符缝隙    3.3 在表达式中有特殊意义，需要添加 “\" 才能匹配该字符本身的字符汇总    字符 说明     ^ 匹配输入字符串的开始位置。要匹配 “^” 字符本身，请使用 “^”   $ 匹配输入字符串的结尾位置。要匹配 “$” 字符本身，请使用 “$”   () 标记一个子表达式的开始和结束位置。要匹配小括号，请使用 “(” 和 “)”   [] 用来自定义能够匹配 ‘多种字符’ 的表达式。要匹配中括号，请使用 “[” 和 “]”   {} 修饰匹配次数的符号。要匹配大括号，请使用 “{” 和 “}”   . 匹配除了换行符（\\n）以外的任意一个字符。要匹配小数点本身，请使用 “.”   ? 修饰匹配次数为 0 次或 1 次。要匹配 “?” 字符本身，请使用 “?”   + 修饰匹配次数为至少 1 次。要匹配 “+” 字符本身，请使用 “+”   * 修饰匹配次数为 0 次或任意次。要匹配 “*” 字符本身，请使用 “*”   | 左右两边表达式之间 “或” 关系。匹配 “|” 本身，请使用 “|”    3.4 括号 “( )” 内的子表达式，如果希望匹配结果不进行记录供以后使用，可以使用 “(?:xxxxx)” 格式 表达式 \"(?:(\\w)\\1)+\" 匹配 \"a bbccdd efg\" 时，结果是 \"bbccdd\"。括号 \"(?:)\" 范围的匹配结果不进行记录，因此 \"(\\w)\" 使用 \"\\1\" 来引用。\n3.5 常用的表达式属性设置简介：Ignorecase，Singleline，Multiline，Global    表达式属性 说明     Ignorecase 默认情况下，表达式中的字母是要区分大小写的。配置为 Ignorecase 可使匹配时不区分大小写。有的表达式引擎，把 “大小写” 概念延伸至 UNICODE 范围的大小写。   Singleline 默认情况下，小数点 \".\" 匹配除了换行符（\\n）以外的字符。配置为 Singleline 可使小数点可匹配包括换行符在内的所有字符。   Multiline 默认情况下，表达式 \"^\" 和 \"$\" 只匹配字符串的开始 ① 和结尾 ④ 位置。如：①xxxxxxxxx②\\n③xxxxxxxxx④配置为 Multiline 可以使 \"^\" 匹配 ① 外，还可以匹配换行符之后，下一行开始前 ③ 的位置，使 \"$\" 匹配 ④ 外，还可以匹配换行符之前，一行结束 ② 的位置。   Global 主要在将表达式用来替换时起作用，配置为 Global 表示替换所有的匹配。    转载自正则表达式参考文档\n","wordCount":"443","inLanguage":"en","datePublished":"2018-06-02T00:00:00Z","dateModified":"2018-06-02T00:00:00Z","author":{"@type":"Person","name":"sunbufu"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://sunbufu.vercel.app/posts/2018-and-before/2018-06-02-rex/"},"publisher":{"@type":"Organization","name":"Sunbufu's blog","logo":{"@type":"ImageObject","url":"https://sunbufu.vercel.app/icon/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script><noscript><style type=text/css>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:#1d1e20;--entry:#2e2e33;--primary:rgba(255, 255, 255, 0.84);--secondary:rgba(255, 255, 255, 0.56);--tertiary:rgba(255, 255, 255, 0.16);--content:rgba(255, 255, 255, 0.74);--hljs-bg:#2e2e33;--code-bg:#37383e;--border:#333}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://sunbufu.vercel.app/ accesskey=h title="Sunbufu's blog (Alt + H)">Sunbufu's blog</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://sunbufu.vercel.app/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://sunbufu.vercel.app/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://sunbufu.vercel.app/about/ title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://sunbufu.vercel.app/>Home</a>&nbsp;»&nbsp;<a href=https://sunbufu.vercel.app/posts/>Posts</a></div><h1 class=post-title>正则表达式</h1><div class=post-description>regular expression</div><div class=post-meta>June 2, 2018&nbsp;·&nbsp;3 min&nbsp;·&nbsp;sunbufu</div></header><div class=post-content><h1 id=引言>引言<a hidden class=anchor aria-hidden=true href=#引言>#</a></h1><p>正则表达式（regular expression）就是用一个“字符串”来描述一个特征，然后去验证另一个“字符串”是否符合这个特征。比如 表达式“ab+” 描述的特征是“一个 &lsquo;a&rsquo; 和 任意个 &lsquo;b&rsquo; ”，那么 &lsquo;ab&rsquo;, &lsquo;abb&rsquo;, &lsquo;abbbbbbbbbb&rsquo; 都符合这个特征。<br>正则表达式可以用来：</p><ol><li>验证字符串是否符合指定特征，比如验证是否是合法的邮件地址。</li><li>用来查找字符串，从一个长的文本中查找符合指定特征的字符串，比查找固定字符串更加灵活方便。</li><li>用来替换，比普通的替换更强大。</li></ol><p>正则表达式学习起来其实是很简单的，不多的几个较为抽象的概念也很容易理解。之所以很多人感觉正则表达式比较复杂，一方面是因为大多数的文档没有做到由浅入深地讲解，概念上没有注意先后顺序，给读者的理解带来困难；另一方面，各种引擎自带的文档一般都要介绍它特有的功能，然而这部分特有的功能并不是我们首先要理解的。</p><h1 id=一-正则表达式规则>一、 正则表达式规则<a hidden class=anchor aria-hidden=true href=#一-正则表达式规则>#</a></h1><h2 id=11-普通字符>1.1 普通字符<a hidden class=anchor aria-hidden=true href=#11-普通字符>#</a></h2><p>字母、数字、汉字、下划线、以及后边章节中没有特殊定义的标点符号，都是"普通字符"。表达式中的普通字符，在匹配一个字符串的时候，匹配与之相同的一个字符。</p><h2 id=12-简单的转义字符>1.2 简单的转义字符<a hidden class=anchor aria-hidden=true href=#12-简单的转义字符>#</a></h2><p>一些不便书写的字符，采用在前面加 <code>"\"</code> 的方法。这些字符其实我们都已经熟知了。</p><table><thead><tr><th>表达式</th><th>可匹配</th></tr></thead><tbody><tr><td><code>\r,\n</code></td><td>代表回车和换行符</td></tr><tr><td><code>\t</code></td><td>制表符</td></tr><tr><td><code>\\</code></td><td>代表<code>\</code>本身</td></tr></tbody></table><p>还有其他一些在后边章节中有特殊用处的标点符号，在前面加 <code>"\"</code> 后，就代表该符号本身。比如：<code>^</code>, <code>$</code> 都有特殊意义，如果要想匹配字符串中 <code>"^"</code> 和 <code>"$"</code> 字符，则表达式就需要写成 <code>"\^"</code> 和 <code>"\$"</code>。</p><table><thead><tr><th>表达式</th><th>可匹配</th></tr></thead><tbody><tr><td><code>\^</code></td><td>匹配<code>^</code>符号本身</td></tr><tr><td><code>\$</code></td><td>匹配<code>$</code>符号本身</td></tr><tr><td><code>\.</code></td><td>匹配小数点<code>.</code>本身</td></tr></tbody></table><p>这些转义字符的匹配方法与 &ldquo;普通字符&rdquo; 是类似的。也是匹配与之相同的一个字符。</p><h2 id=13-能够与-多种字符-匹配的表达式>1.3 能够与 &lsquo;多种字符&rsquo; 匹配的表达式<a hidden class=anchor aria-hidden=true href=#13-能够与-多种字符-匹配的表达式>#</a></h2><p>正则表达式中的一些表示方法，可以匹配 &lsquo;多种字符&rsquo; 其中的任意一个字符。比如，表达式 <code>"\d"</code> 可以匹配任意一个数字。虽然可以匹配其中任意字符，但是只能是一个，不是多个。这就好比玩扑克牌时候，大小王可以代替任意一张牌，但是只能代替一张牌。</p><table><thead><tr><th>表达式</th><th>可匹配</th></tr></thead><tbody><tr><td><code>\d</code></td><td>任意一个数字，0~9 中的任意一个</td></tr><tr><td><code>\w</code></td><td>任意一个字母或数字或下划线，也就是<code>A~Z</code>,<code>a~z</code>,<code>0~9</code>,<code>_</code> 中任意一个</td></tr><tr><td><code>\s</code></td><td>包括空格、制表符、换页符等空白字符的其中任意一个</td></tr><tr><td><code>.</code></td><td>小数点可以匹配除了换行符（<code>\n</code>）以外的任意一个字符</td></tr></tbody></table><h2 id=14-自定义能够匹配-多种字符-的表达式>1.4 自定义能够匹配 &lsquo;多种字符&rsquo; 的表达式<a hidden class=anchor aria-hidden=true href=#14-自定义能够匹配-多种字符-的表达式>#</a></h2><p>使用方括号 <code>[ ]</code> 包含一系列字符，能够匹配其中任意一个字符。用 <code>[^ ]</code> 包含一系列字符，则能够匹配其中字符之外的任意一个字符。同样的道理，虽然可以匹配其中任意一个，但是只能是一个，不是多个。</p><table><thead><tr><th>表达式</th><th>可匹配</th></tr></thead><tbody><tr><td><code>[ab5@]</code></td><td>匹配 <code>"a"</code> 或 <code>"b"</code> 或 <code>"5"</code> 或 <code>"@"</code></td></tr><tr><td><code>[^abc]</code></td><td>匹配 <code>"a"</code>,<code>"b"</code>,<code>"c"</code> 之外的任意一个字符</td></tr><tr><td><code>[f-K]</code></td><td>匹配 <code>"f"~"k"</code> 之间的任意一个字母</td></tr><tr><td><code>[^A-F0-3]</code></td><td>匹配 <code>"A"~"F"</code>,<code>"0"~"3"</code> 之外的任意一个字符</td></tr></tbody></table><h2 id=15-修饰匹配次数的特殊符号>1.5 修饰匹配次数的特殊符号<a hidden class=anchor aria-hidden=true href=#15-修饰匹配次数的特殊符号>#</a></h2><p>前面章节中讲到的表达式，无论是只能匹配一种字符的表达式，还是可以匹配多种字符其中任意一个的表达式，都只能匹配一次。如果使用表达式再加上修饰匹配次数的特殊符号，那么不用重复书写表达式就可以重复匹配。
使用方法是：&ldquo;次数修饰"放在"被修饰的表达式"后边。比如：<code>"[bcd][bcd]"</code> 可以写成 <code>"[bcd]{2}</code>"。</p><table><thead><tr><th>表达式</th><th>作用</th></tr></thead><tbody><tr><td><code>{n}</code></td><td>表达式重复<code>n</code>次</td></tr><tr><td><code>{m,n}</code></td><td>表达式至少重复m次，最多重复n次</td></tr><tr><td><code>{m,}</code></td><td>表达式至少重复m次</td></tr><tr><td><code>?</code></td><td>匹配表达式0次或者1次，相当于<code>{0,1}</code></td></tr><tr><td><code>+</code></td><td>表达式至少出现1次，相当于<code>{1,}</code></td></tr><tr><td><code>*</code></td><td>表达式不出现或出现任意次，相当于<code>{0,}</code></td></tr></tbody></table><h2 id=16-其他一些代表抽象意义的特殊符号>1.6 其他一些代表抽象意义的特殊符号<a hidden class=anchor aria-hidden=true href=#16-其他一些代表抽象意义的特殊符号>#</a></h2><p>一些符号在表达式中代表抽象的特殊意义：</p><table><thead><tr><th>表达式</th><th>作用</th></tr></thead><tbody><tr><td><code>^</code></td><td>与字符串开始的地方匹配，不匹配任何字符</td></tr><tr><td><code>$</code></td><td>与字符串结束的地方匹配，不匹配任何字符</td></tr><tr><td><code>\b</code></td><td>匹配一个单词边界，也就是单词和空格之间的位置，不匹配任何字符</td></tr></tbody></table><p>一些符号可以影响表达式内部的子表达式之间的关系：</p><table><thead><tr><th>表达式</th><th>作用</th></tr></thead><tbody><tr><td>|</td><td>左右两边表达式之间 &ldquo;或&rdquo; 关系，匹配左边或者右边</td></tr><tr><td><code>()</code></td><td>(1)在被修饰匹配次数的时候，括号中的表达式可以作为整体被修饰 (2)取匹配结果的时候，括号中的表达式匹配到的内容可以被单独得到</td></tr></tbody></table><h1 id=二正则表达式中的一些高级规则>二、正则表达式中的一些高级规则<a hidden class=anchor aria-hidden=true href=#二正则表达式中的一些高级规则>#</a></h1><h2 id=21-匹配次数中的贪婪与非贪婪>2.1 匹配次数中的贪婪与非贪婪<a hidden class=anchor aria-hidden=true href=#21-匹配次数中的贪婪与非贪婪>#</a></h2><p>在使用修饰匹配次数的特殊符号时，有几种表示方法可以使同一个表达式能够匹配不同的次数，比如：<code>"{m,n}"</code>, <code>"{m,}"</code>, <code>"?"</code>, <code>"*"</code>, <code>"+"</code>，具体匹配的次数随被匹配的字符串而定。这种重复匹配不定次数的表达式在匹配过程中，总是尽可能多的匹配。比如，针对文本 <code>"dxxxdxxxd"</code>，举例如下：</p><table><thead><tr><th>表达式</th><th>匹配结果</th></tr></thead><tbody><tr><td><code>(d)(\w+)</code></td><td><code>"\w+"</code> 将匹配第一个 <code>"d"</code> 之后的所有字符 <code>"xxxdxxxd"</code></td></tr><tr><td><code>(d)(\w+)(d)</code></td><td><code>"\w+"</code> 将匹配第一个 <code>"d"</code> 和最后一个 <code>"d"</code> 之间的所有字符 <code>"xxxdxxx"</code>。虽然 <code>"\w+"</code> 也能够匹配上最后一个 <code>"d"</code>，但是为了使整个表达式匹配成功，<code>"\w+"</code> 可以 &ldquo;让出&rdquo; 它本来能够匹配的最后一个 <code>"d"</code></td></tr></tbody></table><p>由此可见，<code>"\w+"</code> 在匹配的时候，总是尽可能多的匹配符合它规则的字符。虽然第二个举例中，它没有匹配最后一个 <code>"d"</code>，但那也是为了让整个表达式能够匹配成功。同理，带 <code>"*"</code> 和 <code>"{m,n}"</code> 的表达式都是尽可能地多匹配，带 <code>"?"</code> 的表达式在可匹配可不匹配的时候，也是尽可能的 &ldquo;要匹配&rdquo;。这 种匹配原则就叫作 &ldquo;贪婪&rdquo; 模式 。</p><p><strong>非贪婪模式：</strong>
在修饰匹配次数的特殊符号后再加上一个 <code>"?"</code> 号，则可以使匹配次数不定的表达式尽可能少的匹配，使可匹配可不匹配的表达式，尽可能的 &ldquo;不匹配&rdquo;。这种匹配原则叫作 &ldquo;非贪婪&rdquo; 模式，也叫作 &ldquo;勉强&rdquo; 模式。如果少匹配就会导致整个表达式匹配失败的时候，与贪婪模式类似，非贪婪模式会最小限度的再匹配一些，以使整个表达式匹配成功。举例如下，针对文本 <code>"dxxxdxxxd"</code> 举例：</p><table><thead><tr><th>表达式</th><th>匹配结果</th></tr></thead><tbody><tr><td><code>(d)(\w+?)</code></td><td><code>"\w+?"</code> 将尽可能少的匹配第一个 <code>"d"</code> 之后的字符，结果是：<code>"\w+?"</code> 只匹配了一个 <code>"x"</code></td></tr><tr><td><code>(d)(\w+?)(d)</code></td><td>为了让整个表达式匹配成功，<code>"\w+?"</code> 不得不匹配 <code>"xxx"</code> 才可以让后边的 <code>"d"</code> 匹配，从而使整个表达式匹配成功。因此，结果是：<code>"\w+?"</code> 匹配 <code>"xxx"</code></td></tr></tbody></table><h2 id=22-反向引用-12>2.2 反向引用 \1,\2&mldr;<a hidden class=anchor aria-hidden=true href=#22-反向引用-12>#</a></h2><p>表达式在匹配时，表达式引擎会将小括号 <code>"( )"</code> 包含的表达式所匹配到的字符串记录下来。在获取匹配结果的时候，小括号包含的表达式所匹配到的字符串可以单独获取。这一点，在前面的举例中，已经多次展示了。在实际应用场合中，当用某种边界来查找，而所要获取的内容又不包含边界时，必须使用小括号来指定所要的范围。比如前面的 <code>"&lt;td>(.*?)&lt;/td>"</code>。
其实，&ldquo;小括号包含的表达式所匹配到的字符串&rdquo; 不仅是在匹配结束后才可以使用，在匹配过程中也可以使用。表达式后边的部分，可以引用前面 &ldquo;括号内的子匹配已经匹配到的字符串&rdquo;。引用方法是 <code>"\"</code> 加上一个数字。<code>"\1"</code> 引用第1对括号内匹配到的字符串，<code>"\2"</code> 引用第2对括号内匹配到的字符串……以此类推，如果一对括号内包含另一对括号，则外层的括号先排序号。换句话说，哪一对的左括号 <code>"("</code> 在前，那这一对就先排序号。</p><h2 id=23-预搜索不匹配反向预搜索不匹配>2.3 预搜索，不匹配；反向预搜索，不匹配<a hidden class=anchor aria-hidden=true href=#23-预搜索不匹配反向预搜索不匹配>#</a></h2><p>前面的章节中，我讲到了几个代表抽象意义的特殊符号：<code>"^"</code>，<code>"$"</code>，<code>"\b"</code>。它们都有一个共同点，那就是：它们本身不匹配任何字符，只是对 &ldquo;字符串的两头&rdquo; 或者 &ldquo;字符之间的缝隙&rdquo; 附加了一个条件。理解到这个概念以后，本节将继续介绍另外一种对 &ldquo;两头&rdquo; 或者 &ldquo;缝隙&rdquo; 附加条件的，更加灵活的表示方法。
正向预搜索：<code>"(?=xxxxx)"</code>，<code>"(?!xxxxx)"</code>
格式：<code>"(?=xxxxx)"</code>，在被匹配的字符串中，它对所处的 &ldquo;缝隙&rdquo; 或者 &ldquo;两头&rdquo; 附加的条件是：所在缝隙的右侧，必须能够匹配上 <code>xxxxx</code> 这部分的表达式。因为它只是在此作为这个缝隙上附加的条件，所以它并不影响后边的表达式去真正匹配这个缝隙之后的字符。这就类似 <code>"\b"</code>，本身不匹配任何字符。<code>"\b"</code> 只是将所在缝隙之前、之后的字符取来进行了一下判断，不会影响后边的表达式来真正的匹配。
反向预搜索：<code>"(?&lt;=xxxxx)"</code>，<code>"(?&lt;!xxxxx)"</code>
这两种格式的概念和正向预搜索是类似的，反向预搜索要求的条件是：所在缝隙的 &ldquo;左侧&rdquo;，两种格式分别要求必须能够匹配和必须不能够匹配指定表达式，而不是去判断右侧。与 &ldquo;正向预搜索&rdquo; 一样的是：它们都是对所在缝隙的一种附加条件，本身都不匹配任何字符。</p><h1 id=三其他通用规则>三、其他通用规则<a hidden class=anchor aria-hidden=true href=#三其他通用规则>#</a></h1><p>还有一些在各个正则表达式引擎之间比较通用的规则，在前面的讲解过程中没有提到。</p><h2 id=31-表达式中可以使用-xxx-和-uxxxx-表示一个字符x-表示一个十六进制数>3.1 表达式中，可以使用 &ldquo;\xXX&rdquo; 和 &ldquo;\uXXXX&rdquo; 表示一个字符（&ldquo;X&rdquo; 表示一个十六进制数）<a hidden class=anchor aria-hidden=true href=#31-表达式中可以使用-xxx-和-uxxxx-表示一个字符x-表示一个十六进制数>#</a></h2><table><thead><tr><th>形式</th><th>字符范围</th></tr></thead><tbody><tr><td><code>\xXX</code></td><td>编号在 0 ~ 255 范围的字符</td></tr><tr><td><code>\uXXXX</code></td><td>任何字符可以使用 <code>"\u"</code> 再加上其编号的4位十六进制数表示</td></tr></tbody></table><h2 id=32-在表达式-sdwb-表示特殊意义的同时对应的大写字母表示相反的意义>3.2 在表达式 &ldquo;\s&rdquo;，"\d&rdquo;，"\w"，"\b" 表示特殊意义的同时，对应的大写字母表示相反的意义<a hidden class=anchor aria-hidden=true href=#32-在表达式-sdwb-表示特殊意义的同时对应的大写字母表示相反的意义>#</a></h2><table><thead><tr><th>表达式</th><th>可匹配</th></tr></thead><tbody><tr><td><code>\S</code></td><td>匹配所有非空白字符(<code>\s</code>可匹配各个空白字符)</td></tr><tr><td><code>\D</code></td><td>匹配所有的非数字字符</td></tr><tr><td><code>\W</code></td><td>匹配所有的字母、数字、下划线以外的字符</td></tr><tr><td><code>\B</code></td><td>匹配非单词边界，即左右两边<code>\w</code>范围或者左右两边都不是<code>\w</code>范围时的字符缝隙</td></tr></tbody></table><h2 id=33-在表达式中有特殊意义需要添加--才能匹配该字符本身的字符汇总>3.3 在表达式中有特殊意义，需要添加 &ldquo;" 才能匹配该字符本身的字符汇总<a hidden class=anchor aria-hidden=true href=#33-在表达式中有特殊意义需要添加--才能匹配该字符本身的字符汇总>#</a></h2><table><thead><tr><th>字符</th><th>说明</th></tr></thead><tbody><tr><td><code>^</code></td><td>匹配输入字符串的开始位置。要匹配 &ldquo;^&rdquo; 字符本身，请使用 &ldquo;^&rdquo;</td></tr><tr><td><code>$</code></td><td>匹配输入字符串的结尾位置。要匹配 &ldquo;$&rdquo; 字符本身，请使用 &ldquo;$&rdquo;</td></tr><tr><td><code>()</code></td><td>标记一个子表达式的开始和结束位置。要匹配小括号，请使用 &ldquo;(&rdquo; 和 &ldquo;)&rdquo;</td></tr><tr><td><code>[]</code></td><td>用来自定义能够匹配 &lsquo;多种字符&rsquo; 的表达式。要匹配中括号，请使用 &ldquo;[&rdquo; 和 &ldquo;]&rdquo;</td></tr><tr><td><code>{}</code></td><td>修饰匹配次数的符号。要匹配大括号，请使用 &ldquo;{&rdquo; 和 &ldquo;}&rdquo;</td></tr><tr><td><code>.</code></td><td>匹配除了换行符（\n）以外的任意一个字符。要匹配小数点本身，请使用 &ldquo;.&rdquo;</td></tr><tr><td><code>?</code></td><td>修饰匹配次数为 0 次或 1 次。要匹配 &ldquo;?&rdquo; 字符本身，请使用 &ldquo;?&rdquo;</td></tr><tr><td><code>+</code></td><td>修饰匹配次数为至少 1 次。要匹配 &ldquo;+&rdquo; 字符本身，请使用 &ldquo;+&rdquo;</td></tr><tr><td><code>*</code></td><td>修饰匹配次数为 0 次或任意次。要匹配 &ldquo;*&rdquo; 字符本身，请使用 &ldquo;*&rdquo;</td></tr><tr><td>|</td><td>左右两边表达式之间 &ldquo;或&rdquo; 关系。匹配 &ldquo;|&rdquo; 本身，请使用 &ldquo;|&rdquo;</td></tr></tbody></table><h2 id=34-括号---内的子表达式如果希望匹配结果不进行记录供以后使用可以使用-xxxxx-格式>3.4 括号 &ldquo;( )&rdquo; 内的子表达式，如果希望匹配结果不进行记录供以后使用，可以使用 &ldquo;(?:xxxxx)&rdquo; 格式<a hidden class=anchor aria-hidden=true href=#34-括号---内的子表达式如果希望匹配结果不进行记录供以后使用可以使用-xxxxx-格式>#</a></h2><p>表达式 <code>"(?:(\w)\1)+"</code> 匹配 <code>"a bbccdd efg"</code> 时，结果是 <code>"bbccdd"</code>。括号 <code>"(?:)"</code> 范围的匹配结果不进行记录，因此 <code>"(\w)"</code> 使用 <code>"\1"</code> 来引用。</p><h2 id=35-常用的表达式属性设置简介ignorecasesinglelinemultilineglobal>3.5 常用的表达式属性设置简介：Ignorecase，Singleline，Multiline，Global<a hidden class=anchor aria-hidden=true href=#35-常用的表达式属性设置简介ignorecasesinglelinemultilineglobal>#</a></h2><table><thead><tr><th>表达式属性</th><th>说明</th></tr></thead><tbody><tr><td>Ignorecase</td><td>默认情况下，表达式中的字母是要区分大小写的。配置为 Ignorecase 可使匹配时不区分大小写。有的表达式引擎，把 &ldquo;大小写&rdquo; 概念延伸至 UNICODE 范围的大小写。</td></tr><tr><td>Singleline</td><td>默认情况下，小数点 <code>"."</code> 匹配除了换行符（<code>\n</code>）以外的字符。配置为 Singleline 可使小数点可匹配包括换行符在内的所有字符。</td></tr><tr><td>Multiline</td><td>默认情况下，表达式 <code>"^"</code> 和 <code>"$"</code> 只匹配字符串的开始 ① 和结尾 ④ 位置。如：①<code>xxxxxxxxx</code>②<code>\n</code>③<code>xxxxxxxxx</code>④配置为 Multiline 可以使 <code>"^"</code> 匹配 ① 外，还可以匹配换行符之后，下一行开始前 ③ 的位置，使 <code>"$"</code> 匹配 ④ 外，还可以匹配换行符之前，一行结束 ② 的位置。</td></tr><tr><td>Global</td><td>主要在将表达式用来替换时起作用，配置为 Global 表示替换所有的匹配。</td></tr></tbody></table><p>转载自<a href=http://www.regexlab.com/zh/regref.htm target=_blank rel=noopener>正则表达式参考文档</a></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://sunbufu.vercel.app/tags/basis/>basis</a></li></ul><nav class=paginav><a class=prev href=https://sunbufu.vercel.app/posts/2018-and-before/2018-06-02-database-util/><span class=title>« Prev Page</span><br><span>数据库工具类</span></a>
<a class=next href=https://sunbufu.vercel.app/posts/2018-and-before/2018-06-02-redirect-forward/><span class=title>Next Page »</span><br><span>重定向与请求转发</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2021 <a href=https://sunbufu.vercel.app/>Sunbufu's blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)"><button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></button></a>
<script>let menu=document.getElementById('menu');menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)},document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script></body></html>