<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>常见缓存淘汰算法 | Sunbufu's blog</title><meta name=keywords content="缓存淘汰算法"><meta name=description content="常见缓存淘汰算法"><meta name=author content="sunbufu"><link rel=canonical href=https://sunbufu.vercel.app/posts/2019/2019-01-27-cache-eviction/><link crossorigin=anonymous href=/assets/css/stylesheet.min.2d6dbfc6e0f8a1db1c9d082a76dc11d094328cf63f247bbc2421dfaa7f2bb170.css integrity="sha256-LW2/xuD4odscnQgqdtwR0JQyjPY/JHu8JCHfqn8rsXA=" rel="preload stylesheet" as=style><link rel=preload href=icon/favicon-152x152.png as=image><script defer crossorigin=anonymous src=/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://sunbufu.vercel.app/icon/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://sunbufu.vercel.app/icon/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://sunbufu.vercel.app/icon/favicon-32x32.png><link rel=apple-touch-icon href=https://sunbufu.vercel.app/icon/apple-touch-icon.png><link rel=mask-icon href=https://sunbufu.vercel.app/icon/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.83.1"><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(a,e,f,g,b,c,d){a.GoogleAnalyticsObject=b,a[b]=a[b]||function(){(a[b].q=a[b].q||[]).push(arguments)},a[b].l=1*new Date,c=e.createElement(f),d=e.getElementsByTagName(f)[0],c.async=1,c.src=g,d.parentNode.insertBefore(c,d)}(window,document,'script','https://www.google-analytics.com/analytics.js','ga'),ga('create','UA-123-45','auto'),ga('send','pageview'))</script><meta property="og:title" content="常见缓存淘汰算法"><meta property="og:description" content="常见缓存淘汰算法"><meta property="og:type" content="article"><meta property="og:url" content="https://sunbufu.vercel.app/posts/2019/2019-01-27-cache-eviction/"><meta property="og:image" content="https://sunbufu.vercel.app/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2019-01-27T00:00:00+00:00"><meta property="article:modified_time" content="2019-01-27T00:00:00+00:00"><meta property="og:site_name" content="ExampleSite"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://sunbufu.vercel.app/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="常见缓存淘汰算法"><meta name=twitter:description content="常见缓存淘汰算法"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://sunbufu.vercel.app/posts/"},{"@type":"ListItem","position":2,"name":"常见缓存淘汰算法","item":"https://sunbufu.vercel.app/posts/2019/2019-01-27-cache-eviction/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"常见缓存淘汰算法","name":"常见缓存淘汰算法","description":"常见缓存淘汰算法","keywords":["缓存淘汰算法"],"articleBody":"一、缓存 缓存（Cache） 一词来源于 1967 年的一篇电子工程期刊论文。其作者将法语词 “cache” 赋予 “safekeeping storage” 的涵义，用于计算机工程领域。\n最早是因为 CPU 与内存之间运算和读写速度不一致，在 CPU 添加一块空间用于提前将内存中数据加载进来，提高 整体的速度，这块空间被称为 缓存（Cache）。如今缓存的概念已被扩充，在内存和硬盘之间也有 Cache（磁盘缓存），乃至在硬盘与网络之间也有某种意义上的 Cache ──称为 Internet 临时文件夹或网络内容缓存等。凡是位于速度相差较大的两种硬件之间，用于协调两者数据传输速度差异的结构，均可称之为 Cache。\n但是缓存的空间是宝贵的，所以我们不会将所有的数据都缓存起来，必须依赖一定的规则淘汰掉一部分数据。这个规则就是我们讨论的缓存淘汰算法。\n二、缓存淘汰 2.1 FIFO（先入先出） FIFO (First In FIrst Out) 是最简单的算法，原理跟名字一样，“如果一个数据最先进入缓存中，则应该最早淘汰掉”。把缓存中的数据看成一个队列，最先加入的数据位于队列的头部，最后加入位于队列的尾部。当缓存空间不足需要执行缓存淘汰操作时，从队列的头部开始淘汰。 如下所示，假设我们的缓存可以缓存 3 对数据，1 加入时处于队列的头部，2 和 3 加入时缓存空间充足。当 4 加入时，执行缓存淘汰，由于 1 处于队列的头部，所以被淘汰。同理 5 加入时，2 被淘汰。\nJava 中有单独的队列 Queue ，可以使用 LinkedList。\n   1 2 3 4 5       3=c 4=e 5=f    2=b 2=b 3=c 4=e   1=a 1=a 1=a 2=b 3=c    2.2 LRU（最近最少被使用） LRU (Least Recently Used) 的核心思想是基于**“如果数据最近被访问过，它在未来也极有可能访问过”**。同样把缓存看成一个队列，访问一个数据时，如果缓存中不存在，则插入到队列尾部；如果缓存中存在，则把该数据移动到队列尾部。当执行淘汰操作时，同样从队列的头部开始淘汰。 如下所示，1、2、3 加入时缓存空间充足，接下来 1 又被访问了一次，所以 1 被移动到队列尾部。当 4 加入时，执行缓存淘汰，2 位于队列头部被淘汰。 Java 中可以直接使用 LinkedHashMap 来实现。\n   1 2 3 1 4       3=c 1=a 4=e    2=b 2=b 3=c 1=a   1=a 1=a 1=a 2=b 3=c    2.3 LFU（最不经常使用） LFU （Least Frequently Used）的核心思想是**“如果一个数据在最近一段时间内使用次数很少，那么在将来一段时间内被使用的可能性也很小”**，会记录数据访问的次数，当需要进行淘汰操作时，淘汰掉访问次数最少的数据。 如下所示，一开始 1 被连续访问了两次，接下来 2 被访问一次，3 被访问一次，按照访问次数排序，访问次数少的处于队列头部。当 4 加入时，执行缓存淘汰，2 位于队列头部被淘汰。\n   1 1 2 3 4        1=a (2) 1=a (2)     1=a (2) 3=c (1) 4=e(1)   1=a (1) 1=a (2) 2=b (1) 2=b (1) 3=c (1)    2.4 其他 还有一些其他的淘汰算法：\n 2Q（Two Queues）：同时采用 FIFO 和 LRU 两个队列，首次访问数据时加入到 FIFO 队列中，如果数据在 FIFO 队列移除之前被再次访问，数据会被移动到 LRU 队列中。 LRU-K ：是一种 LRU 算法的增强版，在 LRU 维护队列的基础上，再添加一个队列维护数据访问的次数，由原来访问 1 次会被添加到缓存中，改为访问 K 次才会被加入到缓存中。 ARC：在IBM Almaden研究中心开发，这个缓存算法同时跟踪记录LFU和LRU，以及驱逐缓存条目，来获得可用缓存的最佳使用。  三、常见示例 3.1 Ehcache 中的缓存淘汰 Ehcache 提供了 3 种淘汰机制（驱逐策略），分别是 LRU（默认），LFU，FIFO。但是 Ehcache 的淘汰却不是给予全局的策略，执行步骤如下：\n 判断是否超过最大容量限制 在缓存中随机取出不超过 30 个元素作为样本 根据淘汰策略确定需要淘汰的元素 在缓存中移除元素  3.2 redis 中的缓存淘汰 在 redis 中可以配置 6 中淘汰机制：\n noeviction：不删除策略, 达到最大内存限制时, 如果需要更多内存, 直接返回错误信息。 allkeys-lru：所有 key 通用，优先删除最近最少使用 (LRU) 的 key。 volatile-lru：只限于设置了 expire 的部分; 优先删除最近最少使用 (LRU) 的 key。 allkeys-random：所有 key 通用; 随机删除一部分 key。 volatile-random：只限于设置了 expire 的部分; 随机删除一部分 key。 volatile-ttl：只限于设置了 expire 的部分; 优先删除剩余时间 (time to live,TTL) 短的key。  详细介绍可以参考 官方文档{:target=\"_blank\"} 。\n3.3 Guava 中的缓存淘汰 Guava 在维护缓存数据的同时，还维护了 WirteQueue 和 AccessQueue，分别用来记录写入的记录和访问的记录。总体来说有 4 种淘汰策略：\n Size-base Eviction：基于使用量的淘汰策略。 Timed Eviction：基于时间驱逐，提供了根据访问时间（expireAfterAccess）和根据写入时间（expireAfterWrite）。 Reference-based Eviction：基于引用驱逐（通过 java 的软、弱引用实现）。 Explicit Removals：显示移除。  详细介绍可以参考 官方文档{:target=\"_blank\"}。\n","wordCount":"257","inLanguage":"en","datePublished":"2019-01-27T00:00:00Z","dateModified":"2019-01-27T00:00:00Z","author":{"@type":"Person","name":"sunbufu"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://sunbufu.vercel.app/posts/2019/2019-01-27-cache-eviction/"},"publisher":{"@type":"Organization","name":"Sunbufu's blog","logo":{"@type":"ImageObject","url":"https://sunbufu.vercel.app/icon/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script><noscript><style type=text/css>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:#1d1e20;--entry:#2e2e33;--primary:rgba(255, 255, 255, 0.84);--secondary:rgba(255, 255, 255, 0.56);--tertiary:rgba(255, 255, 255, 0.16);--content:rgba(255, 255, 255, 0.74);--hljs-bg:#2e2e33;--code-bg:#37383e;--border:#333}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://sunbufu.vercel.app/ accesskey=h title="Sunbufu's blog (Alt + H)">Sunbufu's blog</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://sunbufu.vercel.app/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://sunbufu.vercel.app/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://sunbufu.vercel.app/about/ title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://sunbufu.vercel.app/>Home</a>&nbsp;»&nbsp;<a href=https://sunbufu.vercel.app/posts/>Posts</a></div><h1 class=post-title>常见缓存淘汰算法</h1><div class=post-description>常见缓存淘汰算法</div><div class=post-meta>January 27, 2019&nbsp;·&nbsp;2 min&nbsp;·&nbsp;sunbufu</div></header><div class=post-content><h1 id=一缓存>一、缓存<a hidden class=anchor aria-hidden=true href=#一缓存>#</a></h1><p>缓存（Cache） 一词来源于 1967 年的一篇电子工程期刊论文。其作者将法语词 &ldquo;cache&rdquo; 赋予 &ldquo;safekeeping storage&rdquo; 的涵义，用于计算机工程领域。<br>最早是因为 CPU 与内存之间运算和读写速度不一致，在 CPU 添加一块空间用于提前将内存中数据加载进来，提高 整体的速度，这块空间被称为 缓存（Cache）。如今缓存的概念已被扩充，在内存和硬盘之间也有 Cache（磁盘缓存），乃至在硬盘与网络之间也有某种意义上的 Cache ──称为 Internet 临时文件夹或网络内容缓存等。凡是位于速度相差较大的两种硬件之间，用于协调两者数据传输速度差异的结构，均可称之为 Cache。<br>但是缓存的空间是宝贵的，所以我们不会将所有的数据都缓存起来，必须依赖一定的规则淘汰掉一部分数据。这个规则就是我们讨论的缓存淘汰算法。</p><h1 id=二缓存淘汰>二、缓存淘汰<a hidden class=anchor aria-hidden=true href=#二缓存淘汰>#</a></h1><h2 id=21-fifo先入先出>2.1 FIFO（先入先出）<a hidden class=anchor aria-hidden=true href=#21-fifo先入先出>#</a></h2><p>FIFO (First In FIrst Out) 是最简单的算法，原理跟名字一样，<strong>&ldquo;如果一个数据最先进入缓存中，则应该最早淘汰掉&rdquo;</strong>。把缓存中的数据看成一个队列，最先加入的数据位于队列的头部，最后加入位于队列的尾部。当缓存空间不足需要执行缓存淘汰操作时，从队列的头部开始淘汰。
如下所示，假设我们的缓存可以缓存 3 对数据，1 加入时处于队列的头部，2 和 3 加入时缓存空间充足。当 4 加入时，执行缓存淘汰，由于 1 处于队列的头部，所以被淘汰。同理 5 加入时，2 被淘汰。<br>Java 中有单独的队列 <code>Queue</code> ，可以使用 <code>LinkedList</code>。</p><table><thead><tr><th style=text-align:center>1</th><th style=text-align:center>2</th><th style=text-align:center>3</th><th style=text-align:center>4</th><th style=text-align:center>5</th></tr></thead><tbody><tr><td style=text-align:center></td><td style=text-align:center></td><td style=text-align:center>3=c</td><td style=text-align:center>4=e</td><td style=text-align:center>5=f</td></tr><tr><td style=text-align:center></td><td style=text-align:center>2=b</td><td style=text-align:center>2=b</td><td style=text-align:center>3=c</td><td style=text-align:center>4=e</td></tr><tr><td style=text-align:center>1=a</td><td style=text-align:center>1=a</td><td style=text-align:center>1=a</td><td style=text-align:center>2=b</td><td style=text-align:center>3=c</td></tr></tbody></table><h2 id=22-lru最近最少被使用>2.2 LRU（最近最少被使用）<a hidden class=anchor aria-hidden=true href=#22-lru最近最少被使用>#</a></h2><p>LRU (Least Recently Used) 的核心思想是基于**&ldquo;如果数据最近被访问过，它在未来也极有可能访问过&rdquo;**。同样把缓存看成一个队列，访问一个数据时，如果缓存中不存在，则插入到队列尾部；如果缓存中存在，则把该数据移动到队列尾部。当执行淘汰操作时，同样从队列的头部开始淘汰。
如下所示，1、2、3 加入时缓存空间充足，接下来 1 又被访问了一次，所以 1 被移动到队列尾部。当 4 加入时，执行缓存淘汰，2 位于队列头部被淘汰。
Java 中可以直接使用 <code>LinkedHashMap</code> 来实现。</p><table><thead><tr><th style=text-align:center>1</th><th style=text-align:center>2</th><th style=text-align:center>3</th><th style=text-align:center>1</th><th style=text-align:center>4</th></tr></thead><tbody><tr><td style=text-align:center></td><td style=text-align:center></td><td style=text-align:center>3=c</td><td style=text-align:center>1=a</td><td style=text-align:center>4=e</td></tr><tr><td style=text-align:center></td><td style=text-align:center>2=b</td><td style=text-align:center>2=b</td><td style=text-align:center>3=c</td><td style=text-align:center>1=a</td></tr><tr><td style=text-align:center>1=a</td><td style=text-align:center>1=a</td><td style=text-align:center>1=a</td><td style=text-align:center>2=b</td><td style=text-align:center>3=c</td></tr></tbody></table><h2 id=23-lfu最不经常使用>2.3 LFU（最不经常使用）<a hidden class=anchor aria-hidden=true href=#23-lfu最不经常使用>#</a></h2><p>LFU （Least Frequently Used）的核心思想是**&ldquo;如果一个数据在最近一段时间内使用次数很少，那么在将来一段时间内被使用的可能性也很小&rdquo;**，会记录数据访问的次数，当需要进行淘汰操作时，淘汰掉访问次数最少的数据。
如下所示，一开始 1 被连续访问了两次，接下来 2 被访问一次，3 被访问一次，按照访问次数排序，访问次数少的处于队列头部。当 4 加入时，执行缓存淘汰，2 位于队列头部被淘汰。</p><table><thead><tr><th style=text-align:center>1</th><th style=text-align:center>1</th><th style=text-align:center>2</th><th style=text-align:center>3</th><th style=text-align:center>4</th></tr></thead><tbody><tr><td style=text-align:center></td><td style=text-align:center></td><td style=text-align:center></td><td style=text-align:center>1=a (2)</td><td style=text-align:center>1=a (2)</td></tr><tr><td style=text-align:center></td><td style=text-align:center></td><td style=text-align:center>1=a (2)</td><td style=text-align:center>3=c (1)</td><td style=text-align:center>4=e(1)</td></tr><tr><td style=text-align:center>1=a (1)</td><td style=text-align:center>1=a (2)</td><td style=text-align:center>2=b (1)</td><td style=text-align:center>2=b (1)</td><td style=text-align:center>3=c (1)</td></tr></tbody></table><h2 id=24-其他>2.4 其他<a hidden class=anchor aria-hidden=true href=#24-其他>#</a></h2><p>还有一些其他的淘汰算法：</p><ul><li>2Q（Two Queues）：同时采用 FIFO 和 LRU 两个队列，首次访问数据时加入到 FIFO 队列中，如果数据在 FIFO 队列移除之前被再次访问，数据会被移动到 LRU 队列中。</li><li>LRU-K ：是一种 LRU 算法的增强版，在 LRU 维护队列的基础上，再添加一个队列维护数据访问的次数，由原来访问 1 次会被添加到缓存中，改为访问 K 次才会被加入到缓存中。</li><li>ARC：在IBM Almaden研究中心开发，这个缓存算法同时跟踪记录LFU和LRU，以及驱逐缓存条目，来获得可用缓存的最佳使用。</li></ul><h1 id=三常见示例>三、常见示例<a hidden class=anchor aria-hidden=true href=#三常见示例>#</a></h1><h2 id=31-ehcache-中的缓存淘汰>3.1 Ehcache 中的缓存淘汰<a hidden class=anchor aria-hidden=true href=#31-ehcache-中的缓存淘汰>#</a></h2><p>Ehcache 提供了 3 种淘汰机制（驱逐策略），分别是 LRU（默认），LFU，FIFO。但是 Ehcache 的淘汰却不是给予全局的策略，执行步骤如下：</p><ol><li>判断是否超过最大容量限制</li><li>在缓存中随机取出不超过 30 个元素作为样本</li><li>根据淘汰策略确定需要淘汰的元素</li><li>在缓存中移除元素</li></ol><h2 id=32-redis-中的缓存淘汰>3.2 redis 中的缓存淘汰<a hidden class=anchor aria-hidden=true href=#32-redis-中的缓存淘汰>#</a></h2><p>在 redis 中可以配置 6 中淘汰机制：</p><ol><li>noeviction：不删除策略, 达到最大内存限制时, 如果需要更多内存, 直接返回错误信息。</li><li>allkeys-lru：所有 key 通用，优先删除最近最少使用 (LRU) 的 key。</li><li>volatile-lru：只限于设置了 expire 的部分; 优先删除最近最少使用 (LRU) 的 key。</li><li>allkeys-random：所有 key 通用; 随机删除一部分 key。</li><li>volatile-random：只限于设置了 expire 的部分; 随机删除一部分 key。</li><li>volatile-ttl：只限于设置了 expire 的部分; 优先删除剩余时间 (time to live,TTL) 短的key。</li></ol><p>详细介绍可以参考 <a href=https://redis.io/topics/lru-cache/>官方文档</a>{:target="_blank"} 。</p><h2 id=33-guava-中的缓存淘汰>3.3 Guava 中的缓存淘汰<a hidden class=anchor aria-hidden=true href=#33-guava-中的缓存淘汰>#</a></h2><p>Guava 在维护缓存数据的同时，还维护了 WirteQueue 和 AccessQueue，分别用来记录写入的记录和访问的记录。总体来说有 4 种淘汰策略：</p><ol><li>Size-base Eviction：基于使用量的淘汰策略。</li><li>Timed Eviction：基于时间驱逐，提供了根据访问时间（expireAfterAccess）和根据写入时间（expireAfterWrite）。</li><li>Reference-based Eviction：基于引用驱逐（通过 java 的软、弱引用实现）。</li><li>Explicit Removals：显示移除。</li></ol><p>详细介绍可以参考 <a href=https://github.com/google/guava/wiki/CachesExplained>官方文档</a>{:target="_blank"}。</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://sunbufu.vercel.app/tags/algorithm/>algorithm</a></li></ul><nav class=paginav><a class=prev href=https://sunbufu.vercel.app/posts/2019/2019-05-10-about-life/><span class=title>« Prev Page</span><br><span>关于生活的一点思考</span></a>
<a class=next href=https://sunbufu.vercel.app/posts/2019/2019-01-26-annual-summary/><span class=title>Next Page »</span><br><span>2018 年终总结</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2021 <a href=https://sunbufu.vercel.app/>Sunbufu's blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)"><button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></button></a>
<script>let menu=document.getElementById('menu');menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)},document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script></body></html>