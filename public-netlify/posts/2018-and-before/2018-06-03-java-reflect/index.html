<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Java反射 | Sunbufu's blog</title><meta name=keywords content="java,,reflect"><meta name=description content="Java反射的简单介绍"><meta name=author content="sunbufu"><link rel=canonical href=https://sunbufu.netlify.app/posts/2018-and-before/2018-06-03-java-reflect/><link crossorigin=anonymous href=/assets/css/stylesheet.min.b50dea21cb69b925c783abc4870e38fef3e55317f404eef2740034ed7a1c0ac5.css integrity="sha256-tQ3qIctpuSXHg6vEhw44/vPlUxf0BO7ydAA07XocCsU=" rel="preload stylesheet" as=style><link rel=preload href=/icon/favicon-152x152.png as=image><link rel=icon href=https://sunbufu.netlify.app/icon/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://sunbufu.netlify.app/icon/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://sunbufu.netlify.app/icon/favicon-32x32.png><link rel=apple-touch-icon href=https://sunbufu.netlify.app/icon/apple-touch-icon.png><link rel=mask-icon href=https://sunbufu.netlify.app/icon/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.83.1"><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(a,e,f,g,b,c,d){a.GoogleAnalyticsObject=b,a[b]=a[b]||function(){(a[b].q=a[b].q||[]).push(arguments)},a[b].l=1*new Date,c=e.createElement(f),d=e.getElementsByTagName(f)[0],c.async=1,c.src=g,d.parentNode.insertBefore(c,d)}(window,document,'script','https://www.google-analytics.com/analytics.js','ga'),ga('create','UA-123-45','auto'),ga('send','pageview'))</script><meta property="og:title" content="Java反射"><meta property="og:description" content="Java反射的简单介绍"><meta property="og:type" content="article"><meta property="og:url" content="https://sunbufu.netlify.app/posts/2018-and-before/2018-06-03-java-reflect/"><meta property="og:image" content="https://sunbufu.netlify.app/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2018-06-03T00:00:00+00:00"><meta property="article:modified_time" content="2018-06-03T00:00:00+00:00"><meta property="og:site_name" content="ExampleSite"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://sunbufu.netlify.app/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Java反射"><meta name=twitter:description content="Java反射的简单介绍"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://sunbufu.netlify.app/posts/"},{"@type":"ListItem","position":2,"name":"Java反射","item":"https://sunbufu.netlify.app/posts/2018-and-before/2018-06-03-java-reflect/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Java反射","name":"Java反射","description":"Java反射的简单介绍","keywords":["java,","reflect"],"articleBody":"一、Java反射 1.1 Java反射的定义 JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。 JAVA反射（放射）机制：“程序运行时，允许改变程序结构或变量类型，这种语言称为动态语言”。从这个观点看，Perl，Python，Ruby是动态语言，C++，Java，C#不是动态语言。但是JAVA有着一个非常突出的动态相关机制：Reflection，用在Java身上指的是我们可以于运行时加载、探知、使用编译期间完全未知的classes。换句话说，Java程序可以加载一个运行时才得知名称的class，获悉其完整构造（但不包括methods定义），并生成其对象实体、或对其fields设值、或唤起其methods。\n1.2 反射机制的作用：  反编译：*.class–*.java 通过反射机制访问java对象的属性，方法，构造方法等；  1.3 反射相关类 java.lang.Class; java.lang.reflect.Constructor; java.lang.reflect.Field; java.lang.reflect.Method; java.lang.reflect.Modifier; 二、具体功能实现 2.1 反射机制获取类有三种方法，我们来获取Employee类型 //第一种方式：注意此处的Employee必须是全路径名(包名+文件名) Classc1 = Class.forName(\"Employee\"); //第二种方式： //java中每个类型都有class属性. Classc2 = Employee.class; //第三种方式： //java语言中任何一个java对象都有getClass 方法 Employeee = new Employee(); Classc3 = e.getClass(); //c3是运行时类 (e的运行时类是Employee) 2.2 创建对象：获取类以后我们来创建它的对象，利用newInstance： Class c =Class.forName(\"Employee\"); //创建此Class 对象所表示的类的一个新实例 Objecto = c.newInstance(); //调用了Employee的无参数构造方法. 2.3 获取属性：分为所有的属性和指定的属性： a，先获取所有的属性的写法：\n//获取整个类 Class c = Class.forName(\"java.lang.Integer\"); //获取所有的属性 Field[] fs = c.getDeclaredFields(); //定义可变长的字符串，用来存储属性 StringBuffer sb = new StringBuffer(); //通过追加的方法，将每个属性拼接到此字符串中 //最外边的public(访问修饰符)定义 sb.append(Modifier.toString(c.getModifiers()) + \" class \" + c.getSimpleName() +\"{\\n\"); //里边的每一个属性 for(Field field:fs){ sb.append(\"\\t\");//制表符\t\tsb.append(Modifier.toString(field.getModifiers())+\" \");//获得属性的修饰符，例如public，static等等 \tsb.append(field.getType().getSimpleName() + \" \");//属性的类型的名字 \tsb.append(field.getName()+\";\\n\");//属性的名字+回车 } sb.append(\"}\"); System.out.println(sb); b，获取特定的属性，对比着传统的方法来学习：\npublic static void main(String[] args) throws Exception { //以前的方式： \t/* User u = new User(); u.age = 12; //set System.out.println(u.age); //get */ //获取类 \tClass c = Class.forName(\"User\"); //获取id属性 \tField idF = c.getDeclaredField(\"id\"); //实例化这个类赋给o \tObject o = c.newInstance(); //打破封装(JVM运行时不检查属性修饰符) \tidF.setAccessible(true); //使用反射机制可以打破封装性，导致了java对象的属性不安全。 \t//给o对象的id属性赋值\"110\" \tidF.set(o, \"110\"); //set \t//get \tSystem.out.println(idF.get(o)); } 2.4 获取方法，和构造方法，不再详细描述，只来看一下关键字：    方法关键字 含义     getDeclaredMethods() 获取所有的方法   getReturnType() 获得方法的返回类型   getParameterTypes() 获得方法的形式参数类型   getDeclaredMethod(\"方法名\",参数类型.class,……) 获得特定的方法       构造方法关键字 含义     getDeclaredConstructors() 获取所有的构造方法   getDeclaredConstructor(参数类型.class,……) 获取特定的构造方法       父类和父接口 含义     getSuperclass() 获取某类的父类   getInterfaces() 获取某类实现的接口    **补充：**在获得类的方法、属性、构造函数时，会有getXXX和getDeclaredXXX两种对应的方法。之间的区别在于前者返回的是访问权限为public的方法和属性，包括父类中的；但后者返回的是所有访问权限的方法和属性，不包括父类的。\n三、Java反射总结 3.1 Java反射的一般用法（步骤） 使用java的反射机制，一般需要遵循三步：\n 获得你想操作类的Class对象 通过第一步获得的Class对象去取得操作类的方法或是属性名 操作第二步取得的方法或是属性  实例：\n/** * Java 反射练习。 */ public class ReflectionTest { public static void main(String[] args) throws Exception { DisPlay disPlay = new DisPlay(); // 获得Class  Class clazz = disPlay.getClass(); // 通过Class获得DisPlay类的show方法  Method method = clazz.getMethod(\"show\", String.class); // 调用show方法  method.invoke(disPlay, \"Hello\"); } } class DisPlay { public void show(String name) { System.out.println(\"Hello :\" + name); } } 3.2 Java反射分析 3.2.1 反射的用途 (Uses of Reflection) 反射被广泛地用于那些需要在运行时检测或修改程序行为的程序中。这是一个相对高级的特性，只有那些语言基础非常扎实的开发者才应该使用它。如果能把这句警示时刻放在心里，那么反射机制就会成为一项强大的技术，可以让应用程序做一些几乎不可能做到的事情。\n3.2.2 反射的缺点 (Drawbacks of Reflection) 尽管反射非常强大，但也不能滥用。如果一个功能可以不用反射完成，那么最好就不用。在我们使用反射技术时，下面几条内容应该牢记于心：\n性能第一 反射包括了一些动态类型，所以JVM无法对这些代码进行优化。因此，反射操作的效率要比那些非反射操作低得多。我们应该避免在经常被 执行的代码或对性能要求很高的程序中使用反射。\n安全限制 使用反射技术要求程序必须在一个没有安全限制的环境中运行。如果一个程序必须在有安全限制的环境中运行，如Applet，那么这就是个问题了\n内部暴露 由于反射允许代码执行一些在正常情况下不被允许的操作（比如访问私有的属性和方法），所以使用反射可能会导致意料之外的副作用－－代码有功能上的错误，降低可移植性。反射代码破坏了抽象性，因此当平台发生改变的时候，代码的行为就有可能也随着变化。\n参考JAVA中的反射机制、JAVA反射机制-百度百科、Java 反射机制浅析、Java反射机制的缺点\n","wordCount":"253","inLanguage":"en","datePublished":"2018-06-03T00:00:00Z","dateModified":"2018-06-03T00:00:00Z","author":{"@type":"Person","name":"sunbufu"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://sunbufu.netlify.app/posts/2018-and-before/2018-06-03-java-reflect/"},"publisher":{"@type":"Organization","name":"Sunbufu's blog","logo":{"@type":"ImageObject","url":"https://sunbufu.netlify.app/icon/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script><noscript><style type=text/css>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:#1d1e20;--entry:#2e2e33;--primary:rgba(255, 255, 255, 0.84);--secondary:rgba(255, 255, 255, 0.56);--tertiary:rgba(255, 255, 255, 0.16);--content:rgba(255, 255, 255, 0.74);--hljs-bg:#2e2e33;--code-bg:#37383e;--border:#333}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://sunbufu.netlify.app/ accesskey=h title="Sunbufu's blog (Alt + H)">Sunbufu's blog</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://sunbufu.netlify.app/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://sunbufu.netlify.app/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://sunbufu.netlify.app/about/ title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://sunbufu.netlify.app/>Home</a>&nbsp;»&nbsp;<a href=https://sunbufu.netlify.app/posts/>Posts</a></div><h1 class=post-title>Java反射</h1><div class=post-description>Java反射的简单介绍</div><div class=post-meta>June 3, 2018&nbsp;·&nbsp;2 min&nbsp;·&nbsp;sunbufu</div></header><div class=post-content><h1 id=一java反射>一、Java反射<a hidden class=anchor aria-hidden=true href=#一java反射>#</a></h1><h2 id=11-java反射的定义>1.1 Java反射的定义<a hidden class=anchor aria-hidden=true href=#11-java反射的定义>#</a></h2><p>JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。
JAVA反射（放射）机制：“程序运行时，允许改变程序结构或变量类型，这种语言称为动态语言”。从这个观点看，Perl，Python，Ruby是动态语言，C++，Java，C#不是动态语言。但是JAVA有着一个非常突出的动态相关机制：Reflection，用在Java身上指的是我们可以于运行时加载、探知、使用编译期间完全未知的classes。换句话说，Java程序可以加载一个运行时才得知名称的class，获悉其完整构造（但不包括methods定义），并生成其对象实体、或对其fields设值、或唤起其methods。</p><h2 id=12-反射机制的作用>1.2 反射机制的作用：<a hidden class=anchor aria-hidden=true href=#12-反射机制的作用>#</a></h2><ol><li>反编译：<code>*.class</code>&ndash;><code>*.java</code></li><li>通过反射机制访问java对象的属性，方法，构造方法等；</li></ol><h2 id=13-反射相关类>1.3 反射相关类<a hidden class=anchor aria-hidden=true href=#13-反射相关类>#</a></h2><div class=highlight><pre style=color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java>java<span style=color:#5bc4bf>.</span><span style=color:#06b6ef>lang</span><span style=color:#5bc4bf>.</span><span style=color:#06b6ef>Class</span><span style=color:#5bc4bf>;</span>                
java<span style=color:#5bc4bf>.</span><span style=color:#06b6ef>lang</span><span style=color:#5bc4bf>.</span><span style=color:#06b6ef>reflect</span><span style=color:#5bc4bf>.</span><span style=color:#06b6ef>Constructor</span><span style=color:#5bc4bf>;</span> 
java<span style=color:#5bc4bf>.</span><span style=color:#06b6ef>lang</span><span style=color:#5bc4bf>.</span><span style=color:#06b6ef>reflect</span><span style=color:#5bc4bf>.</span><span style=color:#06b6ef>Field</span><span style=color:#5bc4bf>;</span>        
java<span style=color:#5bc4bf>.</span><span style=color:#06b6ef>lang</span><span style=color:#5bc4bf>.</span><span style=color:#06b6ef>reflect</span><span style=color:#5bc4bf>.</span><span style=color:#06b6ef>Method</span><span style=color:#5bc4bf>;</span>
java<span style=color:#5bc4bf>.</span><span style=color:#06b6ef>lang</span><span style=color:#5bc4bf>.</span><span style=color:#06b6ef>reflect</span><span style=color:#5bc4bf>.</span><span style=color:#06b6ef>Modifier</span><span style=color:#5bc4bf>;</span>
</code></pre></div><h1 id=二具体功能实现>二、具体功能实现<a hidden class=anchor aria-hidden=true href=#二具体功能实现>#</a></h1><h2 id=21-反射机制获取类有三种方法我们来获取employee类型>2.1 反射机制获取类有三种方法，我们来获取<code>Employee</code>类型<a hidden class=anchor aria-hidden=true href=#21-反射机制获取类有三种方法我们来获取employee类型>#</a></h2><div class=highlight><pre style=color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#776e71>//第一种方式：注意此处的Employee必须是全路径名(包名+文件名)
</span><span style=color:#776e71></span>Classc1 <span style=color:#5bc4bf>=</span> Class<span style=color:#5bc4bf>.</span><span style=color:#06b6ef>forName</span><span style=color:#5bc4bf>(</span><span style=color:#48b685>&#34;Employee&#34;</span><span style=color:#5bc4bf>);</span>
<span style=color:#776e71>//第二种方式：
</span><span style=color:#776e71>//java中每个类型都有class属性.
</span><span style=color:#776e71></span>Classc2 <span style=color:#5bc4bf>=</span> Employee<span style=color:#5bc4bf>.</span><span style=color:#06b6ef>class</span><span style=color:#5bc4bf>;</span>
<span style=color:#776e71>//第三种方式：
</span><span style=color:#776e71>//java语言中任何一个java对象都有getClass 方法
</span><span style=color:#776e71></span>Employeee <span style=color:#5bc4bf>=</span> <span style=color:#815ba4>new</span> Employee<span style=color:#5bc4bf>();</span>
Classc3 <span style=color:#5bc4bf>=</span> e<span style=color:#5bc4bf>.</span><span style=color:#06b6ef>getClass</span><span style=color:#5bc4bf>();</span> <span style=color:#776e71>//c3是运行时类 (e的运行时类是Employee)
</span></code></pre></div><h2 id=22-创建对象获取类以后我们来创建它的对象利用newinstance>2.2 创建对象：获取类以后我们来创建它的对象，利用<code>newInstance</code>：<a hidden class=anchor aria-hidden=true href=#22-创建对象获取类以后我们来创建它的对象利用newinstance>#</a></h2><div class=highlight><pre style=color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java>Class c <span style=color:#5bc4bf>=</span>Class<span style=color:#5bc4bf>.</span><span style=color:#06b6ef>forName</span><span style=color:#5bc4bf>(</span><span style=color:#48b685>&#34;Employee&#34;</span><span style=color:#5bc4bf>);</span> 
<span style=color:#776e71>//创建此Class 对象所表示的类的一个新实例
</span><span style=color:#776e71></span>Objecto <span style=color:#5bc4bf>=</span> c<span style=color:#5bc4bf>.</span><span style=color:#06b6ef>newInstance</span><span style=color:#5bc4bf>();</span> <span style=color:#776e71>//调用了Employee的无参数构造方法.
</span></code></pre></div><h2 id=23-获取属性分为所有的属性和指定的属性>2.3 获取属性：分为所有的属性和指定的属性：<a hidden class=anchor aria-hidden=true href=#23-获取属性分为所有的属性和指定的属性>#</a></h2><p>a，先获取所有的属性的写法：</p><div class=highlight><pre style=color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#776e71>//获取整个类
</span><span style=color:#776e71></span>Class c <span style=color:#5bc4bf>=</span> Class<span style=color:#5bc4bf>.</span><span style=color:#06b6ef>forName</span><span style=color:#5bc4bf>(</span><span style=color:#48b685>&#34;java.lang.Integer&#34;</span><span style=color:#5bc4bf>);</span>
<span style=color:#776e71>//获取所有的属性
</span><span style=color:#776e71></span>Field<span style=color:#5bc4bf>[]</span> fs <span style=color:#5bc4bf>=</span> c<span style=color:#5bc4bf>.</span><span style=color:#06b6ef>getDeclaredFields</span><span style=color:#5bc4bf>();</span>
<span style=color:#776e71>//定义可变长的字符串，用来存储属性
</span><span style=color:#776e71></span>StringBuffer sb <span style=color:#5bc4bf>=</span> <span style=color:#815ba4>new</span> StringBuffer<span style=color:#5bc4bf>();</span>
<span style=color:#776e71>//通过追加的方法，将每个属性拼接到此字符串中
</span><span style=color:#776e71>//最外边的public(访问修饰符)定义
</span><span style=color:#776e71></span>sb<span style=color:#5bc4bf>.</span><span style=color:#06b6ef>append</span><span style=color:#5bc4bf>(</span>Modifier<span style=color:#5bc4bf>.</span><span style=color:#06b6ef>toString</span><span style=color:#5bc4bf>(</span>c<span style=color:#5bc4bf>.</span><span style=color:#06b6ef>getModifiers</span><span style=color:#5bc4bf>())</span> <span style=color:#5bc4bf>+</span> <span style=color:#48b685>&#34; class &#34;</span> <span style=color:#5bc4bf>+</span> c<span style=color:#5bc4bf>.</span><span style=color:#06b6ef>getSimpleName</span><span style=color:#5bc4bf>()</span> <span style=color:#5bc4bf>+</span><span style=color:#48b685>&#34;{\n&#34;</span><span style=color:#5bc4bf>);</span>
<span style=color:#776e71>//里边的每一个属性
</span><span style=color:#776e71></span><span style=color:#815ba4>for</span><span style=color:#5bc4bf>(</span>Field field<span style=color:#5bc4bf>:</span>fs<span style=color:#5bc4bf>){</span>
	sb<span style=color:#5bc4bf>.</span><span style=color:#06b6ef>append</span><span style=color:#5bc4bf>(</span><span style=color:#48b685>&#34;\t&#34;</span><span style=color:#5bc4bf>);</span><span style=color:#776e71>//制表符			
</span><span style=color:#776e71></span>	sb<span style=color:#5bc4bf>.</span><span style=color:#06b6ef>append</span><span style=color:#5bc4bf>(</span>Modifier<span style=color:#5bc4bf>.</span><span style=color:#06b6ef>toString</span><span style=color:#5bc4bf>(</span>field<span style=color:#5bc4bf>.</span><span style=color:#06b6ef>getModifiers</span><span style=color:#5bc4bf>())+</span><span style=color:#48b685>&#34; &#34;</span><span style=color:#5bc4bf>);</span><span style=color:#776e71>//获得属性的修饰符，例如public，static等等
</span><span style=color:#776e71></span>	sb<span style=color:#5bc4bf>.</span><span style=color:#06b6ef>append</span><span style=color:#5bc4bf>(</span>field<span style=color:#5bc4bf>.</span><span style=color:#06b6ef>getType</span><span style=color:#5bc4bf>().</span><span style=color:#06b6ef>getSimpleName</span><span style=color:#5bc4bf>()</span> <span style=color:#5bc4bf>+</span> <span style=color:#48b685>&#34; &#34;</span><span style=color:#5bc4bf>);</span><span style=color:#776e71>//属性的类型的名字
</span><span style=color:#776e71></span>	sb<span style=color:#5bc4bf>.</span><span style=color:#06b6ef>append</span><span style=color:#5bc4bf>(</span>field<span style=color:#5bc4bf>.</span><span style=color:#06b6ef>getName</span><span style=color:#5bc4bf>()+</span><span style=color:#48b685>&#34;;\n&#34;</span><span style=color:#5bc4bf>);</span><span style=color:#776e71>//属性的名字+回车
</span><span style=color:#776e71></span><span style=color:#5bc4bf>}</span>
sb<span style=color:#5bc4bf>.</span><span style=color:#06b6ef>append</span><span style=color:#5bc4bf>(</span><span style=color:#48b685>&#34;}&#34;</span><span style=color:#5bc4bf>);</span>
System<span style=color:#5bc4bf>.</span><span style=color:#06b6ef>out</span><span style=color:#5bc4bf>.</span><span style=color:#06b6ef>println</span><span style=color:#5bc4bf>(</span>sb<span style=color:#5bc4bf>);</span>
</code></pre></div><p>b，获取特定的属性，对比着传统的方法来学习：</p><div class=highlight><pre style=color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#815ba4>public</span> <span style=color:#815ba4>static</span> <span style=color:#fec418>void</span> <span style=color:#06b6ef>main</span><span style=color:#5bc4bf>(</span>String<span style=color:#5bc4bf>[]</span> args<span style=color:#5bc4bf>)</span> <span style=color:#815ba4>throws</span> Exception <span style=color:#5bc4bf>{</span>
	<span style=color:#776e71>//以前的方式：  
</span><span style=color:#776e71></span>	<span style=color:#776e71>/* 
</span><span style=color:#776e71>	User u = new User(); 
</span><span style=color:#776e71>	u.age = 12; //set 
</span><span style=color:#776e71>	System.out.println(u.age); //get 
</span><span style=color:#776e71>	*/</span>
	
	<span style=color:#776e71>//获取类  
</span><span style=color:#776e71></span>	Class c <span style=color:#5bc4bf>=</span> Class<span style=color:#5bc4bf>.</span><span style=color:#06b6ef>forName</span><span style=color:#5bc4bf>(</span><span style=color:#48b685>&#34;User&#34;</span><span style=color:#5bc4bf>);</span>
	<span style=color:#776e71>//获取id属性  
</span><span style=color:#776e71></span>	Field idF <span style=color:#5bc4bf>=</span> c<span style=color:#5bc4bf>.</span><span style=color:#06b6ef>getDeclaredField</span><span style=color:#5bc4bf>(</span><span style=color:#48b685>&#34;id&#34;</span><span style=color:#5bc4bf>);</span>
	<span style=color:#776e71>//实例化这个类赋给o  
</span><span style=color:#776e71></span>	Object o <span style=color:#5bc4bf>=</span> c<span style=color:#5bc4bf>.</span><span style=color:#06b6ef>newInstance</span><span style=color:#5bc4bf>();</span>
	<span style=color:#776e71>//打破封装(JVM运行时不检查属性修饰符)  
</span><span style=color:#776e71></span>	idF<span style=color:#5bc4bf>.</span><span style=color:#06b6ef>setAccessible</span><span style=color:#5bc4bf>(</span><span style=color:#815ba4>true</span><span style=color:#5bc4bf>);</span> <span style=color:#776e71>//使用反射机制可以打破封装性，导致了java对象的属性不安全。  
</span><span style=color:#776e71></span>	<span style=color:#776e71>//给o对象的id属性赋值&#34;110&#34;  
</span><span style=color:#776e71></span>	idF<span style=color:#5bc4bf>.</span><span style=color:#06b6ef>set</span><span style=color:#5bc4bf>(</span>o<span style=color:#5bc4bf>,</span> <span style=color:#48b685>&#34;110&#34;</span><span style=color:#5bc4bf>);</span> <span style=color:#776e71>//set  
</span><span style=color:#776e71></span>	<span style=color:#776e71>//get  
</span><span style=color:#776e71></span>	System<span style=color:#5bc4bf>.</span><span style=color:#06b6ef>out</span><span style=color:#5bc4bf>.</span><span style=color:#06b6ef>println</span><span style=color:#5bc4bf>(</span>idF<span style=color:#5bc4bf>.</span><span style=color:#06b6ef>get</span><span style=color:#5bc4bf>(</span>o<span style=color:#5bc4bf>));</span>
<span style=color:#5bc4bf>}</span>
</code></pre></div><h2 id=24-获取方法和构造方法不再详细描述只来看一下关键字>2.4 获取方法，和构造方法，不再详细描述，只来看一下关键字：<a hidden class=anchor aria-hidden=true href=#24-获取方法和构造方法不再详细描述只来看一下关键字>#</a></h2><table><thead><tr><th>方法关键字</th><th>含义</th></tr></thead><tbody><tr><td><code>getDeclaredMethods()</code></td><td>获取所有的方法</td></tr><tr><td><code>getReturnType()</code></td><td>获得方法的返回类型</td></tr><tr><td><code>getParameterTypes()</code></td><td>获得方法的形式参数类型</td></tr><tr><td><code>getDeclaredMethod("方法名",参数类型.class,……)</code></td><td>获得特定的方法</td></tr></tbody></table><table><thead><tr><th>构造方法关键字</th><th>含义</th></tr></thead><tbody><tr><td><code>getDeclaredConstructors()</code></td><td>获取所有的构造方法</td></tr><tr><td><code>getDeclaredConstructor(参数类型.class,……)</code></td><td>获取特定的构造方法</td></tr></tbody></table><table><thead><tr><th>父类和父接口</th><th>含义</th></tr></thead><tbody><tr><td><code>getSuperclass()</code></td><td>获取某类的父类</td></tr><tr><td><code>getInterfaces()</code></td><td>获取某类实现的接口</td></tr></tbody></table><p>**补充：**在获得类的方法、属性、构造函数时，会有<code>getXXX</code>和<code>getDeclaredXXX</code>两种对应的方法。之间的区别在于前者返回的是访问权限为<code>public</code>的方法和属性，包括父类中的；但后者返回的是所有访问权限的方法和属性，不包括父类的。</p><h1 id=三java反射总结>三、Java反射总结<a hidden class=anchor aria-hidden=true href=#三java反射总结>#</a></h1><h2 id=31-java反射的一般用法步骤>3.1 Java反射的一般用法（步骤）<a hidden class=anchor aria-hidden=true href=#31-java反射的一般用法步骤>#</a></h2><p>使用java的反射机制，一般需要遵循三步：</p><ol><li>获得你想操作类的<code>Class</code>对象</li><li>通过第一步获得的<code>Class</code>对象去取得操作类的方法或是属性名</li><li>操作第二步取得的方法或是属性</li></ol><p>实例：</p><div class=highlight><pre style=color:#e7e9db;background-color:#2f1e2e;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#776e71>/**
</span><span style=color:#776e71> * Java 反射练习。
</span><span style=color:#776e71> */</span>
<span style=color:#815ba4>public</span> <span style=color:#815ba4>class</span> <span style=color:#fec418>ReflectionTest</span> <span style=color:#5bc4bf>{</span>
    <span style=color:#815ba4>public</span> <span style=color:#815ba4>static</span> <span style=color:#fec418>void</span> <span style=color:#06b6ef>main</span><span style=color:#5bc4bf>(</span>String<span style=color:#5bc4bf>[]</span> args<span style=color:#5bc4bf>)</span> <span style=color:#815ba4>throws</span> Exception <span style=color:#5bc4bf>{</span>
        DisPlay disPlay <span style=color:#5bc4bf>=</span> <span style=color:#815ba4>new</span> DisPlay<span style=color:#5bc4bf>();</span>
        <span style=color:#776e71>// 获得Class
</span><span style=color:#776e71></span>        Class<span style=color:#5bc4bf>&lt;?&gt;</span> clazz <span style=color:#5bc4bf>=</span> disPlay<span style=color:#5bc4bf>.</span><span style=color:#06b6ef>getClass</span><span style=color:#5bc4bf>();</span>
        <span style=color:#776e71>// 通过Class获得DisPlay类的show方法
</span><span style=color:#776e71></span>        Method method <span style=color:#5bc4bf>=</span> clazz<span style=color:#5bc4bf>.</span><span style=color:#06b6ef>getMethod</span><span style=color:#5bc4bf>(</span><span style=color:#48b685>&#34;show&#34;</span><span style=color:#5bc4bf>,</span> String<span style=color:#5bc4bf>.</span><span style=color:#06b6ef>class</span><span style=color:#5bc4bf>);</span>
        <span style=color:#776e71>// 调用show方法
</span><span style=color:#776e71></span>        method<span style=color:#5bc4bf>.</span><span style=color:#06b6ef>invoke</span><span style=color:#5bc4bf>(</span>disPlay<span style=color:#5bc4bf>,</span> <span style=color:#48b685>&#34;Hello&#34;</span><span style=color:#5bc4bf>);</span>
    <span style=color:#5bc4bf>}</span>
<span style=color:#5bc4bf>}</span>

<span style=color:#815ba4>class</span> <span style=color:#fec418>DisPlay</span> <span style=color:#5bc4bf>{</span>
    <span style=color:#815ba4>public</span> <span style=color:#fec418>void</span> <span style=color:#06b6ef>show</span><span style=color:#5bc4bf>(</span>String name<span style=color:#5bc4bf>)</span> <span style=color:#5bc4bf>{</span>
        System<span style=color:#5bc4bf>.</span><span style=color:#06b6ef>out</span><span style=color:#5bc4bf>.</span><span style=color:#06b6ef>println</span><span style=color:#5bc4bf>(</span><span style=color:#48b685>&#34;Hello :&#34;</span> <span style=color:#5bc4bf>+</span> name<span style=color:#5bc4bf>);</span>
    <span style=color:#5bc4bf>}</span>
<span style=color:#5bc4bf>}</span>
</code></pre></div><h2 id=32-java反射分析>3.2 Java反射分析<a hidden class=anchor aria-hidden=true href=#32-java反射分析>#</a></h2><h3 id=321-反射的用途-uses-of-reflection>3.2.1 反射的用途 (Uses of Reflection)<a hidden class=anchor aria-hidden=true href=#321-反射的用途-uses-of-reflection>#</a></h3><p>反射被广泛地用于那些需要在运行时检测或修改程序行为的程序中。这是一个相对高级的特性，只有那些语言基础非常扎实的开发者才应该使用它。如果能把这句警示时刻放在心里，那么反射机制就会成为一项强大的技术，可以让应用程序做一些几乎不可能做到的事情。</p><h3 id=322-反射的缺点-drawbacks-of-reflection>3.2.2 反射的缺点 (Drawbacks of Reflection)<a hidden class=anchor aria-hidden=true href=#322-反射的缺点-drawbacks-of-reflection>#</a></h3><p>尽管反射非常强大，但也不能滥用。如果一个功能可以不用反射完成，那么最好就不用。在我们使用反射技术时，下面几条内容应该牢记于心：</p><p><strong>性能第一</strong> 反射包括了一些动态类型，所以JVM无法对这些代码进行优化。因此，反射操作的效率要比那些非反射操作低得多。我们应该避免在经常被 执行的代码或对性能要求很高的程序中使用反射。</p><p><strong>安全限制</strong> 使用反射技术要求程序必须在一个没有安全限制的环境中运行。如果一个程序必须在有安全限制的环境中运行，如Applet，那么这就是个问题了</p><p><strong>内部暴露</strong> 由于反射允许代码执行一些在正常情况下不被允许的操作（比如访问私有的属性和方法），所以使用反射可能会导致意料之外的副作用－－代码有功能上的错误，降低可移植性。反射代码破坏了抽象性，因此当平台发生改变的时候，代码的行为就有可能也随着变化。</p><p>参考<a href=http://blog.csdn.net/liujiahan629629/article/details/18013523 target=_blank rel=noopener>JAVA中的反射机制</a>、<a href="http://baike.baidu.com/link?url=Q4KEQp6Gc7ZFNWZASTkjANz_R374M2kQC0m5F9eKsKKDCehtRgVm6_O4141Mw_yb9Y_o-KOg1amdft4KqAEOFq" target=_blank rel=noopener>JAVA反射机制-百度百科</a>、<a href=http://www.cnblogs.com/gulvzhe/archive/2012/01/27/2330001.html target=_blank rel=noopener>Java 反射机制浅析</a>、<a href=http://www.cnblogs.com/dyllove98/archive/2013/06/15/3137620.html target=_blank rel=noopener>Java反射机制的缺点</a></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://sunbufu.netlify.app/tags/java/>java</a></li></ul><nav class=paginav><a class=prev href=https://sunbufu.netlify.app/posts/2018-and-before/2018-06-03-ajax/><span class=title>« Prev Page</span><br><span>AJax</span></a>
<a class=next href=https://sunbufu.netlify.app/posts/2018-and-before/2018-06-03-java-aes/><span class=title>Next Page »</span><br><span>Java实现AES加密</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2021 <a href=https://sunbufu.netlify.app/>Sunbufu's blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)"><button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></button></a>
<script>let menu=document.getElementById('menu');menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)},document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script></body></html>