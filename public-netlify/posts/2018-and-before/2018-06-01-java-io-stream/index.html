<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Java IO流 | Sunbufu's blog</title><meta name=keywords content="java,,io"><meta name=description content="java IO流总结"><meta name=author content="sunbufu"><link rel=canonical href=https://sunbufu.netlify.app/posts/2018-and-before/2018-06-01-java-io-stream/><link crossorigin=anonymous href=/assets/css/stylesheet.min.2d6dbfc6e0f8a1db1c9d082a76dc11d094328cf63f247bbc2421dfaa7f2bb170.css integrity="sha256-LW2/xuD4odscnQgqdtwR0JQyjPY/JHu8JCHfqn8rsXA=" rel="preload stylesheet" as=style><link rel=preload href=icon/favicon-152x152.png as=image><script defer crossorigin=anonymous src=/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://sunbufu.netlify.app/icon/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://sunbufu.netlify.app/icon/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://sunbufu.netlify.app/icon/favicon-32x32.png><link rel=apple-touch-icon href=https://sunbufu.netlify.app/icon/apple-touch-icon.png><link rel=mask-icon href=https://sunbufu.netlify.app/icon/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.83.1"><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(a,e,f,g,b,c,d){a.GoogleAnalyticsObject=b,a[b]=a[b]||function(){(a[b].q=a[b].q||[]).push(arguments)},a[b].l=1*new Date,c=e.createElement(f),d=e.getElementsByTagName(f)[0],c.async=1,c.src=g,d.parentNode.insertBefore(c,d)}(window,document,'script','https://www.google-analytics.com/analytics.js','ga'),ga('create','UA-123-45','auto'),ga('send','pageview'))</script><meta property="og:title" content="Java IO流"><meta property="og:description" content="java IO流总结"><meta property="og:type" content="article"><meta property="og:url" content="https://sunbufu.netlify.app/posts/2018-and-before/2018-06-01-java-io-stream/"><meta property="og:image" content="https://sunbufu.netlify.app/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2018-06-01T00:00:00+00:00"><meta property="article:modified_time" content="2018-06-01T00:00:00+00:00"><meta property="og:site_name" content="ExampleSite"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://sunbufu.netlify.app/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Java IO流"><meta name=twitter:description content="java IO流总结"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://sunbufu.netlify.app/posts/"},{"@type":"ListItem","position":2,"name":"Java IO流","item":"https://sunbufu.netlify.app/posts/2018-and-before/2018-06-01-java-io-stream/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Java IO流","name":"Java IO流","description":"java IO流总结","keywords":["java,","io"],"articleBody":"一、流(Stream) 1、流(Stream)的定义 流是个抽象的概念，是对输入输出设备的抽象，Java程序中，对于数据的输入/输出操作都是以“流”的方式进行。设备可以是文件，网络，内存等。 流具有方向性，至于是输入流还是输出流则是一个相对的概念，一般以程序为参考，如果数据的流向是程序至设备，我们成为输出流，反之我们称为输入流。 可以将流想象成一个“水流管道”，水流就在这管道中形成了，自然就出现了方向的概念。 2、流的特点 1) 方向性 2) 连续性 3) 单位性 3、IO流的分类  从方向性分：输入流(Input Stream)和输出流(Output Stream) 从单位性分：字节流(8为二进制(bit))和字符流 从功能分（从是否有数据源）：节点流和处理流  4、在Java中，所有的流均来自于java.io包四个抽象类 1)抽象的字节输入流类：InputStream\n2)抽象的字节输出流类：OutputStream\n3)抽象的字符输入流类：Reader\n4)抽象的字符输出流类：Writer\n 二、四个基本抽象类 使用步骤：\n1）声明对象\n2）创建对象\n3）使用（输入输出）\n4）刷新（flush()输出的时候） 5）关闭\n1、抽象的字节输入流类（InputStream）及其文件操作实现类（FileInputStream） 1）以字节方式来读取数据 2）提供的常用方法： int read();//用来读取一个字节，反馈这个字节对应的整数[0, 255]。当返回-1是，表示读取结束 void close();//关闭字节输入流，释放所占资源，确保数据安全 2、抽象的字节输出流类（OutputStream）及其文件操作实现类（FileOutputStream） 1) 将给定的数据以字节方式输出到文件中； 2) 它提供的常用方法: void write( int x );// 将给定的整数以字节方式输出。因此，当给定的整数超出了[ 0, 255 ]时，则会失真。 void flush();// 将缓冲区中的数据一次性输出到目的地。确保数据输出成功。 void close();// 关闭字节输出流，释放所占资源，确保数据安全。 注意：必须使用flush()方法。\nWindows文件中输出换行使用/r/n，即回车换行。（回车指：将光标回到该行的首部。换行指：将光标移到下一行。）\n3、字符输入流类（Reader）及其文件操作实现类（FileReader） 1）它以字符的方式来读取数据。 2）他提供的方法： int read();// 它以字符方式来读取数据，并反馈这个数据的int型值。因此，其范围是[ 0, 65535 ]；当反馈一个-1时，则结束。 void close();// 关闭字符输入流。 4、字符输出流类（Writer）及其文件操作实现类（FileWriter） 1) 将给定的数据以字符方式输出。 2) 它提供的常用方法: void write( int x );// 将给定的整数以字符方式输出，数据在[ 0, 65535 ]范围中。 void flush();// 将缓冲区中的数据一次性输出，确保输出成功。 void close();// 关闭输出流，释放所在占资源，确保安全。 5、字节流和字符流的区别： 1) 字节流可以处理任意类型的文件。 2) 字符流只能用来处理文本文件。 三、四个缓冲流类（属于处理流） 作用：用来提高输入和输出的效率\n注意：使用时需要套接在节点流上\n1、字节缓冲流 BufferedInputStream 字节缓冲输入流\nBufferedOutputStream 字节缓冲输出流\n应用在FileInputStream和FileOutputStream的基础上\nFileInputStream fis = new FileInputStream( path_r ); FileOutputStream fos = new FileOutputStream( path_w ); BufferedInputStream bis = new BufferedInputStream( fis ); //将节点流处理成缓冲流 BufferedOutputStream bos = new BufferedOutputStream( fos ); 2、字符缓冲流 BufferedReader 字符缓冲输入流\nBufferedWriter 字符缓冲输出流\n应用在FIleReader和FileWriter的基础上\nFileReader fr = new FileReader( path_r ); FileWriter fw = new FileWriter( path_w ); BufferedReader br = new BufferedReader( fr ); //将节点流处理成缓冲流 BufferedWriter bw = new BufferedWriter( fw ); 四、数据流（属于处理流） 目的：保证数据类型不变\n注意：使用时需要套接在节点流上，存储和读取时顺序必须一致（因为数据流按照队列存储）。\n1、DataInputStream数据的字节输入流类 用来读取八种基本类型的数据及字符串。\nbyte readByte();// byte short readShort();// short int readInt();// int long readLong();// long char readChar();// char float readFloat();// float double readDouble();// double boolean readBoolean();// boolean String readUTF();// string 2、DataOutputStrean数据的字节输出流类 用来输出八种基本类型的数据及字符串\nvoid writeByte(byte);// byte void writeShort(short);// short void writeInt(int);// int void writeLong(long);// long void writeChar(char);// char void writeFloat(float);// float void writeDouble(double);// double void writeBoolean(boolean);// boolean void wirteUTF(String);// string 五、对象流（属于处理流） 作用：保证对象的性质不变\n注意：\n 使用时需要套接在节点流上，要存储的对象必须实现java.io.Serializable接口\ntransient 修饰属性或方法，表示该属性或方法不可以序列化\n 1、ObjectInputStream对象的字节输入流类 读取对象\nObjectInputStream ois = new ObjectInputStream(new FileInputStream(path)); 2、ObjectOutputStream对象的字节输出流类 输出对象\nObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(path)); 六、转换流（属于处理流） 在使用FileInputStream时，读取数据乱码，给的数据和要的数据在单位上不一致，则需要转换流处理。\n1、InputStreamReader（字节转换成字符的输入流类） 功能：\n1）字节转换成字符，以字符的方式读取数据 2）在创建转换流对象时，可以指定字符编码方案，实现数据的管理\nInputStreamReader isr = new InputStreamReader(new FileInputStream(path), \"utf-8\"); 2、OutputStreamWriter（字符转换成字节的输出流类） 功能：\n1）字符转换成字节，以字节方式将给定数据输出\n2）在创建转换流对象时，可以指定字符编码方案，实现数据的管理\nOutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(path), \"utf-8\"); 十、打印流（输入输出流） 特点：\n 均属于输出流，模拟打印机的特点来输出信息\n具有字符转化成字节的自动转换功能\n打印流输出后，会自动调用flush()方法。\n他提供的常用方法print();和println();。\n打印流属于节点流（不直接连接数据源，不需要套接到数据流上）。\n 了解：\n System类的静态字段： out默认是屏幕，可以通过System.setOut(PrintStream);,修改\nin默认是键盘\nerr错误信息，默认也是屏幕\n 1、字节打印流(PrintStream) System.out.println();//这个方法属于字节打印流 2、字符打印流(PrintWriter) ","wordCount":"292","inLanguage":"en","datePublished":"2018-06-01T00:00:00Z","dateModified":"2018-06-01T00:00:00Z","author":{"@type":"Person","name":"sunbufu"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://sunbufu.netlify.app/posts/2018-and-before/2018-06-01-java-io-stream/"},"publisher":{"@type":"Organization","name":"Sunbufu's blog","logo":{"@type":"ImageObject","url":"https://sunbufu.netlify.app/icon/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script><noscript><style type=text/css>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:#1d1e20;--entry:#2e2e33;--primary:rgba(255, 255, 255, 0.84);--secondary:rgba(255, 255, 255, 0.56);--tertiary:rgba(255, 255, 255, 0.16);--content:rgba(255, 255, 255, 0.74);--hljs-bg:#2e2e33;--code-bg:#37383e;--border:#333}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://sunbufu.netlify.app/ accesskey=h title="Sunbufu's blog (Alt + H)">Sunbufu's blog</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://sunbufu.netlify.app/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://sunbufu.netlify.app/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://sunbufu.netlify.app/about/ title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://sunbufu.netlify.app/>Home</a>&nbsp;»&nbsp;<a href=https://sunbufu.netlify.app/posts/>Posts</a></div><h1 class=post-title>Java IO流</h1><div class=post-description>java IO流总结</div><div class=post-meta>June 1, 2018&nbsp;·&nbsp;2 min&nbsp;·&nbsp;sunbufu</div></header><div class=post-content><h1 id=一流stream>一、流(Stream)<a hidden class=anchor aria-hidden=true href=#一流stream>#</a></h1><h2 id=1流stream的定义>1、流(Stream)的定义<a hidden class=anchor aria-hidden=true href=#1流stream的定义>#</a></h2><p>流是个抽象的概念，是对输入输出设备的抽象，Java程序中，对于数据的输入/输出操作都是以“流”的方式进行。设备可以是文件，网络，内存等。
<img loading=lazy src=/posts/2018-and-before/20151026090104644.png alt=流></p><p>流具有方向性，至于是输入流还是输出流则是一个相对的概念，一般以程序为参考，如果数据的流向是程序至设备，我们成为输出流，反之我们称为输入流。
可以将流想象成一个“水流管道”，水流就在这管道中形成了，自然就出现了方向的概念。
<img loading=lazy src=/posts/2018-and-before/20151026090019118.jpeg alt=流的方向性></p><h2 id=2流的特点>2、流的特点<a hidden class=anchor aria-hidden=true href=#2流的特点>#</a></h2><h3 id=1-方向性>1) 方向性<a hidden class=anchor aria-hidden=true href=#1-方向性>#</a></h3><h3 id=2-连续性>2) 连续性<a hidden class=anchor aria-hidden=true href=#2-连续性>#</a></h3><h3 id=3-单位性>3) 单位性<a hidden class=anchor aria-hidden=true href=#3-单位性>#</a></h3><h2 id=3io流的分类>3、IO流的分类<a hidden class=anchor aria-hidden=true href=#3io流的分类>#</a></h2><ol><li>从方向性分：输入流(<code>Input Stream</code>)和输出流(<code>Output Stream</code>)</li><li>从单位性分：字节流(8为二进制(<code>bit</code>))和字符流</li><li>从功能分（从是否有数据源）：节点流和处理流</li></ol><h2 id=4在java中所有的流均来自于javaio包四个抽象类>4、在Java中，所有的流均来自于<code>java.io</code>包四个抽象类<a hidden class=anchor aria-hidden=true href=#4在java中所有的流均来自于javaio包四个抽象类>#</a></h2><p>1)抽象的字节输入流类：<code>InputStream</code><br>2)抽象的字节输出流类：<code>OutputStream</code><br>3)抽象的字符输入流类：<code>Reader</code><br>4)抽象的字符输出流类：<code>Writer</code></p><hr><h1 id=二四个基本抽象类>二、四个基本抽象类<a hidden class=anchor aria-hidden=true href=#二四个基本抽象类>#</a></h1><p><strong>使用步骤：</strong><br>1）声明对象<br>2）创建对象<br>3）使用（输入输出）<br>4）刷新（<code>flush()</code>输出的时候）
5）关闭</p><h2 id=1抽象的字节输入流类inputstream及其文件操作实现类fileinputstream>1、抽象的字节输入流类（InputStream）及其文件操作实现类（FileInputStream）<a hidden class=anchor aria-hidden=true href=#1抽象的字节输入流类inputstream及其文件操作实现类fileinputstream>#</a></h2><h3 id=1以字节方式来读取数据>1）以字节方式来读取数据<a hidden class=anchor aria-hidden=true href=#1以字节方式来读取数据>#</a></h3><h3 id=2提供的常用方法>2）提供的常用方法：<a hidden class=anchor aria-hidden=true href=#2提供的常用方法>#</a></h3><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>read</span><span style=color:#f92672>();</span><span style=color:#75715e>//用来读取一个字节，反馈这个字节对应的整数[0, 255]。当返回-1是，表示读取结束
</span><span style=color:#75715e></span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>close</span><span style=color:#f92672>();</span><span style=color:#75715e>//关闭字节输入流，释放所占资源，确保数据安全
</span></code></pre></div><h2 id=2抽象的字节输出流类outputstream及其文件操作实现类fileoutputstream>2、抽象的字节输出流类（OutputStream）及其文件操作实现类（FileOutputStream）<a hidden class=anchor aria-hidden=true href=#2抽象的字节输出流类outputstream及其文件操作实现类fileoutputstream>#</a></h2><h3 id=1-将给定的数据以字节方式输出到文件中>1) 将给定的数据以字节方式输出到文件中；<a hidden class=anchor aria-hidden=true href=#1-将给定的数据以字节方式输出到文件中>#</a></h3><h3 id=2-它提供的常用方法>2) 它提供的常用方法:<a hidden class=anchor aria-hidden=true href=#2-它提供的常用方法>#</a></h3><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>write</span><span style=color:#f92672>(</span> <span style=color:#66d9ef>int</span> x <span style=color:#f92672>);</span><span style=color:#75715e>//  将给定的整数以字节方式输出。因此，当给定的整数超出了[ 0, 255 ]时，则会失真。
</span><span style=color:#75715e></span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>flush</span><span style=color:#f92672>();</span><span style=color:#75715e>// 将缓冲区中的数据一次性输出到目的地。确保数据输出成功。
</span><span style=color:#75715e></span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>close</span><span style=color:#f92672>();</span><span style=color:#75715e>// 关闭字节输出流，释放所占资源，确保数据安全。
</span></code></pre></div><p>注意：必须使用<code>flush()</code>方法。<br>Windows文件中输出换行使用<code>/r/n</code>，即回车换行。（回车指：将光标回到该行的首部。换行指：将光标移到下一行。）</p><h2 id=3字符输入流类reader及其文件操作实现类filereader>3、字符输入流类（Reader）及其文件操作实现类（FileReader）<a hidden class=anchor aria-hidden=true href=#3字符输入流类reader及其文件操作实现类filereader>#</a></h2><h3 id=1它以字符的方式来读取数据>1）它以字符的方式来读取数据。<a hidden class=anchor aria-hidden=true href=#1它以字符的方式来读取数据>#</a></h3><h3 id=2他提供的方法>2）他提供的方法：<a hidden class=anchor aria-hidden=true href=#2他提供的方法>#</a></h3><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>read</span><span style=color:#f92672>();</span><span style=color:#75715e>//  它以字符方式来读取数据，并反馈这个数据的int型值。因此，其范围是[ 0, 65535 ]；当反馈一个-1时，则结束。
</span><span style=color:#75715e></span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>close</span><span style=color:#f92672>();</span><span style=color:#75715e>// 关闭字符输入流。
</span></code></pre></div><h2 id=4字符输出流类writer及其文件操作实现类filewriter>4、字符输出流类（Writer）及其文件操作实现类（FileWriter）<a hidden class=anchor aria-hidden=true href=#4字符输出流类writer及其文件操作实现类filewriter>#</a></h2><h3 id=1-将给定的数据以字符方式输出>1) 将给定的数据以字符方式输出。<a hidden class=anchor aria-hidden=true href=#1-将给定的数据以字符方式输出>#</a></h3><h3 id=2-它提供的常用方法-1>2) 它提供的常用方法:<a hidden class=anchor aria-hidden=true href=#2-它提供的常用方法-1>#</a></h3><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>write</span><span style=color:#f92672>(</span> <span style=color:#66d9ef>int</span> x <span style=color:#f92672>);</span><span style=color:#75715e>//  将给定的整数以字符方式输出，数据在[ 0, 65535 ]范围中。
</span><span style=color:#75715e></span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>flush</span><span style=color:#f92672>();</span><span style=color:#75715e>// 将缓冲区中的数据一次性输出，确保输出成功。
</span><span style=color:#75715e></span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>close</span><span style=color:#f92672>();</span><span style=color:#75715e>// 关闭输出流，释放所在占资源，确保安全。
</span></code></pre></div><h2 id=5字节流和字符流的区别>5、字节流和字符流的区别：<a hidden class=anchor aria-hidden=true href=#5字节流和字符流的区别>#</a></h2><h3 id=1-字节流可以处理任意类型的文件>1) 字节流可以处理任意类型的文件。<a hidden class=anchor aria-hidden=true href=#1-字节流可以处理任意类型的文件>#</a></h3><h3 id=2-字符流只能用来处理文本文件>2) 字符流只能用来处理文本文件。<a hidden class=anchor aria-hidden=true href=#2-字符流只能用来处理文本文件>#</a></h3><h1 id=三四个缓冲流类属于处理流>三、四个缓冲流类（属于处理流）<a hidden class=anchor aria-hidden=true href=#三四个缓冲流类属于处理流>#</a></h1><p>作用：用来<strong>提高</strong>输入和输出的<strong>效率</strong><br>注意：使用时需要套接在节点流上</p><h2 id=1字节缓冲流>1、字节缓冲流<a hidden class=anchor aria-hidden=true href=#1字节缓冲流>#</a></h2><p><code>BufferedInputStream</code> 字节缓冲输入流<br><code>BufferedOutputStream</code> 字节缓冲输出流<br>应用在<code>FileInputStream</code>和<code>FileOutputStream</code>的基础上</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java>FileInputStream fis <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> FileInputStream<span style=color:#f92672>(</span> path_r <span style=color:#f92672>);</span>
FileOutputStream fos <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> FileOutputStream<span style=color:#f92672>(</span> path_w <span style=color:#f92672>);</span>
BufferedInputStream bis <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> BufferedInputStream<span style=color:#f92672>(</span> fis <span style=color:#f92672>);</span> <span style=color:#75715e>//将节点流处理成缓冲流
</span><span style=color:#75715e></span>BufferedOutputStream bos <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> BufferedOutputStream<span style=color:#f92672>(</span> fos <span style=color:#f92672>);</span> 
</code></pre></div><h2 id=2字符缓冲流>2、字符缓冲流<a hidden class=anchor aria-hidden=true href=#2字符缓冲流>#</a></h2><p><code>BufferedReader</code> 字符缓冲输入流<br><code>BufferedWriter</code> 字符缓冲输出流<br>应用在<code>FIleReader</code>和<code>FileWriter</code>的基础上</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java>FileReader fr <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> FileReader<span style=color:#f92672>(</span> path_r <span style=color:#f92672>);</span>
FileWriter fw <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> FileWriter<span style=color:#f92672>(</span> path_w <span style=color:#f92672>);</span>
BufferedReader br <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> BufferedReader<span style=color:#f92672>(</span> fr <span style=color:#f92672>);</span> <span style=color:#75715e>//将节点流处理成缓冲流
</span><span style=color:#75715e></span>BufferedWriter bw <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> BufferedWriter<span style=color:#f92672>(</span> fw <span style=color:#f92672>);</span> 
</code></pre></div><h1 id=四数据流属于处理流>四、数据流（属于处理流）<a hidden class=anchor aria-hidden=true href=#四数据流属于处理流>#</a></h1><p>目的：保证<strong>数据类型不变</strong><br>注意：使用时需要套接在节点流上，存储和读取时顺序必须一致（因为数据流按照队列存储）。</p><h2 id=1datainputstream数据的字节输入流类>1、DataInputStream数据的字节输入流类<a hidden class=anchor aria-hidden=true href=#1datainputstream数据的字节输入流类>#</a></h2><p>用来<strong>读取八种基本类型</strong>的数据及字符串。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#66d9ef>byte</span> <span style=color:#a6e22e>readByte</span><span style=color:#f92672>();</span><span style=color:#75715e>// byte
</span><span style=color:#75715e></span><span style=color:#66d9ef>short</span> <span style=color:#a6e22e>readShort</span><span style=color:#f92672>();</span><span style=color:#75715e>// short
</span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>readInt</span><span style=color:#f92672>();</span><span style=color:#75715e>// int
</span><span style=color:#75715e></span><span style=color:#66d9ef>long</span> <span style=color:#a6e22e>readLong</span><span style=color:#f92672>();</span><span style=color:#75715e>// long
</span><span style=color:#75715e></span><span style=color:#66d9ef>char</span> <span style=color:#a6e22e>readChar</span><span style=color:#f92672>();</span><span style=color:#75715e>// char
</span><span style=color:#75715e></span><span style=color:#66d9ef>float</span> <span style=color:#a6e22e>readFloat</span><span style=color:#f92672>();</span><span style=color:#75715e>// float
</span><span style=color:#75715e></span><span style=color:#66d9ef>double</span> <span style=color:#a6e22e>readDouble</span><span style=color:#f92672>();</span><span style=color:#75715e>// double
</span><span style=color:#75715e></span><span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>readBoolean</span><span style=color:#f92672>();</span><span style=color:#75715e>// boolean
</span><span style=color:#75715e></span>String <span style=color:#a6e22e>readUTF</span><span style=color:#f92672>();</span><span style=color:#75715e>// string
</span></code></pre></div><h2 id=2dataoutputstrean数据的字节输出流类>2、DataOutputStrean数据的字节输出流类<a hidden class=anchor aria-hidden=true href=#2dataoutputstrean数据的字节输出流类>#</a></h2><p>用来<strong>输出八种基本类型</strong>的数据及字符串</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>writeByte</span><span style=color:#f92672>(</span><span style=color:#66d9ef>byte</span><span style=color:#f92672>);</span><span style=color:#75715e>// byte
</span><span style=color:#75715e></span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>writeShort</span><span style=color:#f92672>(</span><span style=color:#66d9ef>short</span><span style=color:#f92672>);</span><span style=color:#75715e>// short
</span><span style=color:#75715e></span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>writeInt</span><span style=color:#f92672>(</span><span style=color:#66d9ef>int</span><span style=color:#f92672>);</span><span style=color:#75715e>// int
</span><span style=color:#75715e></span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>writeLong</span><span style=color:#f92672>(</span><span style=color:#66d9ef>long</span><span style=color:#f92672>);</span><span style=color:#75715e>// long
</span><span style=color:#75715e></span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>writeChar</span><span style=color:#f92672>(</span><span style=color:#66d9ef>char</span><span style=color:#f92672>);</span><span style=color:#75715e>// char
</span><span style=color:#75715e></span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>writeFloat</span><span style=color:#f92672>(</span><span style=color:#66d9ef>float</span><span style=color:#f92672>);</span><span style=color:#75715e>// float
</span><span style=color:#75715e></span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>writeDouble</span><span style=color:#f92672>(</span><span style=color:#66d9ef>double</span><span style=color:#f92672>);</span><span style=color:#75715e>// double
</span><span style=color:#75715e></span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>writeBoolean</span><span style=color:#f92672>(</span><span style=color:#66d9ef>boolean</span><span style=color:#f92672>);</span><span style=color:#75715e>// boolean
</span><span style=color:#75715e></span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>wirteUTF</span><span style=color:#f92672>(</span>String<span style=color:#f92672>);</span><span style=color:#75715e>// string
</span></code></pre></div><h1 id=五对象流属于处理流>五、对象流（属于处理流）<a hidden class=anchor aria-hidden=true href=#五对象流属于处理流>#</a></h1><p>作用：<strong>保证对象的性质不变</strong><br>注意：</p><blockquote><p>使用时需要套接在节点流上，要存储的对象<strong>必须实现<code>java.io.Serializable</code>接口</strong><br><code>transient</code> 修饰属性或方法，表示该属性或方法不可以序列化</p></blockquote><h2 id=1objectinputstream对象的字节输入流类>1、ObjectInputStream对象的字节输入流类<a hidden class=anchor aria-hidden=true href=#1objectinputstream对象的字节输入流类>#</a></h2><p>读取对象</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java>ObjectInputStream ois <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ObjectInputStream<span style=color:#f92672>(</span><span style=color:#66d9ef>new</span> FileInputStream<span style=color:#f92672>(</span>path<span style=color:#f92672>));</span>
</code></pre></div><h2 id=2objectoutputstream对象的字节输出流类>2、ObjectOutputStream对象的字节输出流类<a hidden class=anchor aria-hidden=true href=#2objectoutputstream对象的字节输出流类>#</a></h2><p>输出对象</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java>ObjectOutputStream oos <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ObjectOutputStream<span style=color:#f92672>(</span><span style=color:#66d9ef>new</span> FileOutputStream<span style=color:#f92672>(</span>path<span style=color:#f92672>));</span>
</code></pre></div><h1 id=六转换流属于处理流>六、转换流（属于处理流）<a hidden class=anchor aria-hidden=true href=#六转换流属于处理流>#</a></h1><p>在使用<code>FileInputStream</code>时，读取数据乱码，<strong>给的数据和要的数据在单位上不一致，则需要转换流处理</strong>。</p><h2 id=1inputstreamreader字节转换成字符的输入流类>1、InputStreamReader（字节转换成字符的输入流类）<a hidden class=anchor aria-hidden=true href=#1inputstreamreader字节转换成字符的输入流类>#</a></h2><p>功能：<br>1）<strong>字节转换成字符</strong>，以字符的方式读取数据<br>2）在创建转换流对象时，可以<strong>指定字符编码方案，实现数据的管理</strong></p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java>InputStreamReader isr <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> InputStreamReader<span style=color:#f92672>(</span><span style=color:#66d9ef>new</span> FileInputStream<span style=color:#f92672>(</span>path<span style=color:#f92672>),</span> <span style=color:#e6db74>&#34;utf-8&#34;</span><span style=color:#f92672>);</span>
</code></pre></div><h2 id=2outputstreamwriter字符转换成字节的输出流类>2、OutputStreamWriter（字符转换成字节的输出流类）<a hidden class=anchor aria-hidden=true href=#2outputstreamwriter字符转换成字节的输出流类>#</a></h2><p>功能：<br>1）<strong>字符转换成字节</strong>，以字节方式将给定数据输出<br>2）在创建转换流对象时，可以<strong>指定字符编码方案，实现数据的管理</strong></p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java>OutputStreamWriter osw <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> OutputStreamWriter<span style=color:#f92672>(</span><span style=color:#66d9ef>new</span> FileOutputStream<span style=color:#f92672>(</span>path<span style=color:#f92672>),</span> <span style=color:#e6db74>&#34;utf-8&#34;</span><span style=color:#f92672>);</span>
</code></pre></div><h1 id=十打印流输入输出流>十、打印流（输入输出流）<a hidden class=anchor aria-hidden=true href=#十打印流输入输出流>#</a></h1><p>特点：</p><blockquote><p>均<strong>属于输出流</strong>，模拟打印机的特点来输出信息<br>具有<strong>字符转化成字节</strong>的自动转换功能<br>打印流输出后，会<strong>自动调用<code>flush()</code><strong>方法。<br>他提供的常用方法<code>print();</code>和<code>println();</code>。<br>打印流</strong>属于节点流</strong>（不直接连接数据源，不需要套接到数据流上）。</p></blockquote><p>了解：</p><blockquote><p>System类的静态字段：
<code>out</code>默认是屏幕，可以通过<code>System.setOut(PrintStream);</code>,修改<br><code>in</code>默认是键盘<br><code>err</code>错误信息，默认也是屏幕</p></blockquote><h2 id=1字节打印流printstream>1、字节打印流(PrintStream)<a hidden class=anchor aria-hidden=true href=#1字节打印流printstream>#</a></h2><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java>System<span style=color:#f92672>.</span><span style=color:#a6e22e>out</span><span style=color:#f92672>.</span><span style=color:#a6e22e>println</span><span style=color:#f92672>();</span><span style=color:#75715e>//这个方法属于字节打印流
</span></code></pre></div><h2 id=2字符打印流printwriter>2、字符打印流(PrintWriter)<a hidden class=anchor aria-hidden=true href=#2字符打印流printwriter>#</a></h2></div><footer class=post-footer><ul class=post-tags><li><a href=https://sunbufu.netlify.app/tags/java/>java</a></li></ul><nav class=paginav><a class=prev href=https://sunbufu.netlify.app/posts/2018-and-before/2018-06-01-html/><span class=title>« Prev Page</span><br><span>html</span></a>
<a class=next href=https://sunbufu.netlify.app/posts/2018-and-before/2018-06-01-javascript/><span class=title>Next Page »</span><br><span>javascript</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2021 <a href=https://sunbufu.netlify.app/>Sunbufu's blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)"><button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></button></a>
<script>let menu=document.getElementById('menu');menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)},document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script></body></html>